////==--- primate_vector.td - Primate V-ext Builtin function list -----------===//
////
////  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
////  See https://llvm.org/LICENSE.txt for license information.
////  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
////
////===----------------------------------------------------------------------===//
////
//// This file defines the builtins for Primate V-extension. See:
////
////     https://github.com/primate/prv-intrinsic-doc
////
////===----------------------------------------------------------------------===//
//
////===----------------------------------------------------------------------===//
//// Instruction definitions
////===----------------------------------------------------------------------===//
//// Each record of the class PRVBuiltin defines a collection of builtins (i.e.
//// "def vadd : PRVBuiltin" will be used to define things like "vadd_vv_i32m1",
//// "vadd_vv_i32m2", etc).
////
//// The elements of this collection are defined by an instantiation process the
//// range of which is specified by the cross product of the LMUL attribute and
//// every element in the attribute TypeRange. By default builtins have LMUL = [1,
//// 2, 4, 8, 1/2, 1/4, 1/8] so the process is repeated 7 times. In tablegen we
//// use the Log2LMUL [0, 1, 2, 3, -1, -2, -3] to represent the LMUL.
////
//// LMUL represents the fact that the types of values used by that builtin are
//// values generated by instructions that are executed under that LMUL. However,
//// this does not mean the builtin is necessarily lowered into an instruction
//// that executes under the specified LMUL. An example where this happens are
//// loads and stores of masks. A mask like `vbool8_t` can be generated, for
//// instance, by comparing two `__prv_int8m1_t` (this is LMUL=1) or comparing two
//// `__prv_int16m2_t` (this is LMUL=2). The actual load or store, however, will
//// be performed under LMUL=1 because mask registers are not grouped.
////
//// TypeRange is a non-empty sequence of basic types:
////
////   c: int8_t (i8)
////   s: int16_t (i16)
////   i: int32_t (i32)
////   l: int64_t (i64)
////   x: float16_t (half)
////   f: float32_t (float)
////   d: float64_t (double)
////
//// This way, given an LMUL, a record with a TypeRange "sil" will cause the
//// definition of 3 builtins. Each type "t" in the TypeRange (in this example
//// they are int16_t, int32_t, int64_t) is used as a parameter that drives the
//// definition of that particular builtin (for the given LMUL).
////
//// During the instantiation, types can be transformed or modified using type
//// transformers. Given a type "t" the following primitive type transformers can
//// be applied to it to yield another type.
////
////   e: type of "t" as is (identity)
////   v: computes a vector type whose element type is "t" for the current LMUL
////   w: computes a vector type identical to what 'v' computes except for the
////      element type which is twice as wide as the element type of 'v'
////   q: computes a vector type identical to what 'v' computes except for the
////      element type which is four times as wide as the element type of 'v'
////   o: computes a vector type identical to what 'v' computes except for the
////      element type which is eight times as wide as the element type of 'v'
////   m: computes a vector type identical to what 'v' computes except for the
////      element type which is bool
////   0: void type, ignores "t"
////   z: size_t, ignores "t"
////   t: ptrdiff_t, ignores "t"
////   u: unsigned long, ignores "t"
////   l: long, ignores "t"
////
//// So for instance if t is "i", i.e. int, then "e" will yield int again. "v"
//// will yield an PRV vector type (assume LMUL=1), so __prv_int32m1_t.
//// Accordingly "w" would yield __prv_int64m2_t.
////
//// A type transformer can be prefixed by other non-primitive type transformers.
////
////   P: constructs a pointer to the current type
////   C: adds const to the type
////   K: requires the integer type to be a constant expression
////   U: given an integer type or vector type, computes its unsigned variant
////   I: given a vector type, compute the vector type with integer type
////      elements of the same width
////   F: given a vector type, compute the vector type with floating-point type
////      elements of the same width
////   S: given a vector type, computes its equivalent one for LMUL=1. This is a
////      no-op if the vector was already LMUL=1
////   (Log2EEW:Value): Log2EEW value could be 3/4/5/6 (8/16/32/64), given a
////      vector type (SEW and LMUL) and EEW (8/16/32/64), computes its
////      equivalent integer vector type with EEW and corresponding ELMUL (elmul =
////      (eew/sew) * lmul). For example, vector type is __prv_float16m4
////      (SEW=16, LMUL=4) and Log2EEW is 3 (EEW=8), and then equivalent vector
////      type is __prv_uint8m2_t (elmul=(8/16)*4 = 2). Ignore to define a new
////      builtins if its equivalent type has illegal lmul.
////   (FixedSEW:Value): Given a vector type (SEW and LMUL), and computes another
////      vector type which only changed SEW as given value. Ignore to define a new
////      builtin if its equivalent type has illegal lmul or the SEW does not changed.
////   (SFixedLog2LMUL:Value): Smaller Fixed Log2LMUL. Given a vector type (SEW
////      and LMUL), and computes another vector type which only changed LMUL as
////      given value. The new LMUL should be smaller than the old one. Ignore to
////      define a new builtin if its equivalent type has illegal lmul.
////   (LFixedLog2LMUL:Value): Larger Fixed Log2LMUL. Given a vector type (SEW
////      and LMUL), and computes another vector type which only changed LMUL as
////      given value. The new LMUL should be larger than the old one. Ignore to
////      define a new builtin if its equivalent type has illegal lmul.
////
//// Following with the example above, if t is "i", then "Ue" will yield unsigned
//// int and "Fv" will yield __prv_float32m1_t (again assuming LMUL=1), Fw would
//// yield __prv_float64m2_t, etc.
////
//// Each builtin is then defined by applying each type in TypeRange against the
//// sequence of type transformers described in Suffix and Prototype.
////
//// The name of the builtin is defined by the Name attribute (which defaults to
//// the name of the class) appended (separated with an underscore) the Suffix
//// attribute. For instance with Name="foo", Suffix = "v" and TypeRange = "il",
//// the builtin generated will be __builtin_prv_foo_i32m1 and
//// __builtin_prv_foo_i64m1 (under LMUL=1). If Suffix contains more than one
//// type transformer (say "vv") each of the types is separated with an
//// underscore as in "__builtin_prv_foo_i32m1_i32m1".
////
//// The C/C++ prototype of the builtin is defined by the Prototype attribute.
//// Prototype is a non-empty sequence of type transformers, the first of which
//// is the return type of the builtin and the rest are the parameters of the
//// builtin, in order. For instance if Prototype is "wvv" and TypeRange is "si"
//// a first builtin will have type
//// __prv_int32m2_t (__prv_int16m1_t, __prv_int16m1_t) and the second builtin
//// will have type __prv_int64m2_t (__prv_int32m1_t, __prv_int32m1_t) (again
//// under LMUL=1).
////
//// There are a number of attributes that are used to constraint the number and
//// shape of the builtins generated. Refer to the comments below for them.
//class PRVBuiltin<string suffix, string prototype, string type_range,
//                 string mangled_suffix = ""> {
//  // Base name that will be prepended in __builtin_prv_ and appended the
//  // computed Suffix.
//  string Name = NAME;
//
//  // If not empty, each instantiated builtin will have this appended after an
//  // underscore (_). It is instantiated like Prototype.
//  string Suffix = suffix;
//
//  // If empty, default MangledName is sub string of `Name` which end of first
//  // '_'. For example, the default mangled name  is `vadd` for Name `vadd_vv`.
//  // It's used for describe some special naming cases.
//  string MangledName = "";
//
//  // If not empty, each MangledName will have this appended after an
//  // underscore (_). It is instantiated like Prototype.
//  string MangledSuffix = mangled_suffix;
//
//  // The different variants of the builtin, parameterised with a type.
//  string TypeRange = type_range;
//
//  // We use each type described in TypeRange and LMUL with prototype to
//  // instantiate a specific element of the set of builtins being defined.
//  // Prototype attribute defines the C/C++ prototype of the builtin. It is a
//  // non-empty sequence of type transformers, the first of which is the return
//  // type of the builtin and the rest are the parameters of the builtin, in
//  // order. For instance if Prototype is "wvv", TypeRange is "si" and LMUL=1, a
//  // first builtin will have type
//  // __prv_int32m2_t (__prv_int16m1_t, __prv_int16m1_t), and the second builtin
//  // will have type __prv_int64m2_t (__prv_int32m1_t, __prv_int32m1_t).
//  string Prototype = prototype;
//
//  // This builtin has a masked form.
//  bit HasMask = true;
//
//  // If HasMask, this flag states that this builtin has a maskedoff operand. It
//  // is always the first operand in builtin and IR intrinsic.
//  bit HasMaskedOffOperand = true;
//
//  // This builtin has a granted vector length parameter in the last position.
//  bit HasVL = true;
//
//  // This builtin supports non-masked function overloading api.
//  // All masked operations support overloading api.
//  bit HasNoMaskedOverloaded = true;
//
//  // Reads or writes "memory" or has other side-effects.
//  bit HasSideEffects = false;
//
//  // This builtin is valid for the given Log2LMULs.
//  list<int> Log2LMUL = [0, 1, 2, 3, -1, -2, -3];
//
//  // Manual code in clang codegen primate_vector_builtin_cg.inc
//  code ManualCodegen = [{}];
//  code ManualCodegenMask = [{}];
//
//  // When emit the automatic clang codegen, it describes what types we have to use
//  // to obtain the specific LLVM intrinsic. -1 means the return type, otherwise,
//  // k >= 0 meaning the k-th operand (counting from zero) of the codegen'd
//  // parameter of the unmasked version. k can't be the mask operand's position.
//  list<int> IntrinsicTypes = [];
//
//  // If these names are not empty, this is the ID of the LLVM intrinsic
//  // we want to lower to.
//  string IRName = NAME;
//
//  // If HasMask, this is the ID of the LLVM intrinsic we want to lower to.
//  string IRNameMask = NAME #"_mask";
//
//  // If non empty, this is the code emitted in the header, otherwise
//  // an automatic definition in header is emitted.
//  string HeaderCode = "";
//
//  // Sub extension of vector spec. Currently only support Zvamo or Zvlsseg.
//  string RequiredExtension = "";
//
//  // Number of fields for Zvlsseg.
//  int NF = 1;
//}
//
////===----------------------------------------------------------------------===//
//// Basic classes with automatic codegen.
////===----------------------------------------------------------------------===//
//
//class PRVOutBuiltin<string suffix, string prototype, string type_range>
//    : PRVBuiltin<suffix, prototype, type_range> {
//  let IntrinsicTypes = [-1];
//}
//
//class PRVOp0Builtin<string suffix, string prototype, string type_range>
//    : PRVBuiltin<suffix, prototype, type_range> {
//  let IntrinsicTypes = [0];
//}
//
//class PRVOutOp1Builtin<string suffix, string prototype, string type_range>
//    : PRVBuiltin<suffix, prototype, type_range> {
//  let IntrinsicTypes = [-1, 1];
//}
//
//class PRVOutOp0Op1Builtin<string suffix, string prototype, string type_range>
//    : PRVBuiltin<suffix, prototype, type_range> {
//  let IntrinsicTypes = [-1, 0, 1];
//}
//
//multiclass PRVBuiltinSet<string intrinsic_name, string type_range,
//                         list<list<string>> suffixes_prototypes,
//                         list<int> intrinsic_types> {
//  let IRName = intrinsic_name, IRNameMask = intrinsic_name # "_mask",
//      IntrinsicTypes = intrinsic_types in {
//    foreach s_p = suffixes_prototypes in {
//      let Name = NAME # "_" # s_p[0] in {
//        defvar suffix = s_p[1];
//        defvar prototype = s_p[2];
//        def : PRVBuiltin<suffix, prototype, type_range>;
//      }
//    }
//  }
//}
//
//// IntrinsicTypes is output, op0, op1 [-1, 0, 1]
//multiclass PRVOutOp0Op1BuiltinSet<string intrinsic_name, string type_range,
//                                  list<list<string>> suffixes_prototypes>
//    : PRVBuiltinSet<intrinsic_name, type_range, suffixes_prototypes,
//                            [-1, 0, 1]>;
//
//multiclass PRVOutBuiltinSet<string intrinsic_name, string type_range,
//                            list<list<string>> suffixes_prototypes>
//    : PRVBuiltinSet<intrinsic_name, type_range, suffixes_prototypes, [-1]>;
//
//multiclass PRVOp0BuiltinSet<string intrinsic_name, string type_range,
//                            list<list<string>> suffixes_prototypes>
//    : PRVBuiltinSet<intrinsic_name, type_range, suffixes_prototypes, [0]>;
//
//// IntrinsicTypes is output, op1 [-1, 1]
//multiclass PRVOutOp1BuiltinSet<string intrinsic_name, string type_range,
//                               list<list<string>> suffixes_prototypes>
//    : PRVBuiltinSet<intrinsic_name, type_range, suffixes_prototypes, [-1, 1]>;
//
//multiclass PRVOp0Op1BuiltinSet<string intrinsic_name, string type_range,
//                               list<list<string>> suffixes_prototypes>
//    : PRVBuiltinSet<intrinsic_name, type_range, suffixes_prototypes, [0, 1]>;
//
//multiclass PRVOutOp1Op2BuiltinSet<string intrinsic_name, string type_range,
//                                  list<list<string>> suffixes_prototypes>
//    : PRVBuiltinSet<intrinsic_name, type_range, suffixes_prototypes, [-1, 1, 2]>;
//
//multiclass PRVSignedBinBuiltinSet
//    : PRVOutOp1BuiltinSet<NAME, "csil",
//                          [["vv", "v", "vvv"],
//                           ["vx", "v", "vve"]]>;
//
//multiclass PRVUnsignedBinBuiltinSet
//    : PRVOutOp1BuiltinSet<NAME, "csil",
//                          [["vv", "Uv", "UvUvUv"],
//                           ["vx", "Uv", "UvUvUe"]]>;
//
//multiclass PRVIntBinBuiltinSet
//    : PRVSignedBinBuiltinSet,
//      PRVUnsignedBinBuiltinSet;
//
//multiclass PRVSlideOneBuiltinSet
//    : PRVOutOp1BuiltinSet<NAME, "csil",
//                          [["vx", "v", "vve"],
//                           ["vx", "Uv", "UvUve"]]>;
//
//multiclass PRVSignedShiftBuiltinSet
//    : PRVOutOp1BuiltinSet<NAME, "csil",
//                          [["vv", "v", "vvUv"],
//                           ["vx", "v", "vvz"]]>;
//
//multiclass PRVUnsignedShiftBuiltinSet
//    : PRVOutOp1BuiltinSet<NAME, "csil",
//                          [["vv", "Uv", "UvUvUv"],
//                           ["vx", "Uv", "UvUvz"]]>;
//
//multiclass PRVShiftBuiltinSet
//    : PRVSignedShiftBuiltinSet,
//      PRVUnsignedShiftBuiltinSet;
//
//let Log2LMUL = [-3, -2, -1, 0, 1, 2] in {
//  multiclass PRVSignedNShiftBuiltinSet
//      : PRVOutOp0Op1BuiltinSet<NAME, "csil",
//                                     [["wv", "v", "vwUv"],
//                                      ["wx", "v", "vwz"]]>;
//  multiclass PRVUnsignedNShiftBuiltinSet
//      : PRVOutOp0Op1BuiltinSet<NAME, "csil",
//                                     [["wv", "Uv", "UvUwUv"],
//                                      ["wx", "Uv", "UvUwz"]]>;
//}
//
//multiclass PRVCarryinBuiltinSet
//    : PRVOutOp1BuiltinSet<NAME, "csil",
//                          [["vvm", "v", "vvvm"],
//                           ["vxm", "v", "vvem"],
//                           ["vvm", "Uv", "UvUvUvm"],
//                           ["vxm", "Uv", "UvUvUem"]]>;
//
//multiclass PRVCarryOutInBuiltinSet<string intrinsic_name>
//    : PRVOp0Op1BuiltinSet<intrinsic_name, "csil",
//                          [["vvm", "vm", "mvvm"],
//                           ["vxm", "vm", "mvem"],
//                           ["vvm", "Uvm", "mUvUvm"],
//                           ["vxm", "Uvm", "mUvUem"]]>;
//
//multiclass PRVSignedMaskOutBuiltinSet
//    : PRVOp0Op1BuiltinSet<NAME, "csil",
//                          [["vv", "vm", "mvv"],
//                           ["vx", "vm", "mve"]]>;
//
//multiclass PRVUnsignedMaskOutBuiltinSet
//    : PRVOp0Op1BuiltinSet<NAME, "csil",
//                          [["vv", "Uvm", "mUvUv"],
//                           ["vx", "Uvm", "mUvUe"]]>;
//
//multiclass PRVIntMaskOutBuiltinSet
//    : PRVSignedMaskOutBuiltinSet,
//      PRVUnsignedMaskOutBuiltinSet;
//
//class PRVIntExt<string intrinsic_name, string suffix, string prototype,
//                string type_range>
//    : PRVBuiltin<suffix, prototype, type_range> {
//  let IRName = intrinsic_name;
//  let IRNameMask = intrinsic_name # "_mask";
//  let MangledName = NAME;
//  let IntrinsicTypes = [-1, 0];
//}
//
//let HasMaskedOffOperand = false in {
//  multiclass PRVIntTerBuiltinSet {
//    defm "" : PRVOutOp1BuiltinSet<NAME, "csil",
//                                  [["vv", "v", "vvvv"],
//                                   ["vx", "v", "vvev"],
//                                   ["vv", "Uv", "UvUvUvUv"],
//                                   ["vx", "Uv", "UvUvUeUv"]]>;
//  }
//  multiclass PRVFloatingTerBuiltinSet {
//    defm "" : PRVOutOp1BuiltinSet<NAME, "xfd",
//                                  [["vv", "v", "vvvv"],
//                                   ["vf", "v", "vvev"]]>;
//  }
//}
//
//let HasMaskedOffOperand = false, Log2LMUL = [-2, -1, 0, 1, 2] in {
//  multiclass PRVFloatingWidenTerBuiltinSet {
//    defm ""  : PRVOutOp1Op2BuiltinSet<NAME, "xf",
//                                      [["vv", "w", "wwvv"],
//                                       ["vf", "w", "wwev"]]>;
//  }
//}
//
//multiclass PRVFloatingBinBuiltinSet
//    : PRVOutOp1BuiltinSet<NAME, "xfd",
//                          [["vv", "v", "vvv"],
//                           ["vf", "v", "vve"]]>;
//
//multiclass PRVFloatingBinVFBuiltinSet
//    : PRVOutOp1BuiltinSet<NAME, "xfd",
//                          [["vf", "v", "vve"]]>;
//
//multiclass PRVFloatingMaskOutBuiltinSet
//    : PRVOp0Op1BuiltinSet<NAME, "xfd",
//                          [["vv", "vm", "mvv"],
//                           ["vf", "vm", "mve"]]>;
//
//multiclass PRVFloatingMaskOutVFBuiltinSet
//    : PRVOp0Op1BuiltinSet<NAME, "fd",
//                          [["vf", "vm", "mve"]]>;
//
//class PRVMaskBinBuiltin : PRVOutBuiltin<"m", "mmm", "c"> {
//  let Name = NAME # "_mm";
//  let HasMask = false;
//}
//
//class PRVMaskUnaryBuiltin : PRVOutBuiltin<"m", "mm", "c"> {
//  let Name = NAME # "_m";
//}
//
//class PRVMaskNullaryBuiltin : PRVOutBuiltin<"m", "m", "c"> {
//  let Name = NAME # "_m";
//  let HasMask = false;
//  let HasNoMaskedOverloaded = false;
//}
//
//class PRVMaskOp0Builtin<string prototype> : PRVOp0Builtin<"m", prototype, "c"> {
//  let Name = NAME # "_m";
//  let HasMaskedOffOperand = false;
//}
//
//let HasMaskedOffOperand = false in {
//  multiclass PRVSlideBuiltinSet {
//    defm "" : PRVOutBuiltinSet<NAME, "csilxfd",
//                               [["vx","v", "vvvz"]]>;
//    defm "" : PRVOutBuiltinSet<NAME, "csil",
//                               [["vx","Uv", "UvUvUvz"]]>;
//  }
//}
//
//class PRVFloatingUnaryBuiltin<string builtin_suffix, string ir_suffix,
//                              string prototype>
//    : PRVOutBuiltin<ir_suffix, prototype, "xfd"> {
//  let Name = NAME # "_" # builtin_suffix;
//}
//
//class PRVFloatingUnaryVVBuiltin : PRVFloatingUnaryBuiltin<"v", "v", "vv">;
//
//class PRVConvBuiltin<string suffix, string prototype, string type_range,
//                     string mangled_name>
//    : PRVBuiltin<suffix, prototype, type_range> {
//  let IntrinsicTypes = [-1, 0];
//  let MangledName = mangled_name;
//}
//
//class PRVConvToSignedBuiltin<string mangled_name>
//    : PRVConvBuiltin<"Iv", "Ivv", "xfd", mangled_name>;
//
//class PRVConvToUnsignedBuiltin<string mangled_name>
//    : PRVConvBuiltin<"Uv", "Uvv", "xfd", mangled_name>;
//
//class PRVConvToWidenSignedBuiltin<string mangled_name>
//    : PRVConvBuiltin<"Iw", "Iwv", "xf", mangled_name>;
//
//class PRVConvToWidenUnsignedBuiltin<string mangled_name>
//    : PRVConvBuiltin<"Uw", "Uwv", "xf", mangled_name>;
//
//class PRVConvToNarrowingSignedBuiltin<string mangled_name>
//    : PRVConvBuiltin<"Iv", "IvFw", "csi", mangled_name>;
//
//class PRVConvToNarrowingUnsignedBuiltin<string mangled_name>
//    : PRVConvBuiltin<"Uv", "UvFw", "csi", mangled_name>;
//
//let HasMaskedOffOperand = false in {
//  multiclass PRVSignedReductionBuiltin {
//    defm "" : PRVOutOp1BuiltinSet<NAME, "csil",
//                                  [["vs", "vSv", "SvSvvSv"]]>;
//  }
//  multiclass PRVUnsignedReductionBuiltin {
//    defm "" : PRVOutOp1BuiltinSet<NAME, "csil",
//                                  [["vs", "UvUSv", "USvUSvUvUSv"]]>;
//  }
//  multiclass PRVFloatingReductionBuiltin {
//    defm "" : PRVOutOp1BuiltinSet<NAME, "xfd",
//                                  [["vs", "vSv", "SvSvvSv"]]>;
//  }
//  multiclass PRVFloatingWidenReductionBuiltin {
//    defm "" : PRVOutOp1BuiltinSet<NAME, "xf",
//                                  [["vs", "vSw", "SwSwvSw"]]>;
//  }
//}
//
//multiclass PRVIntReductionBuiltinSet
//    : PRVSignedReductionBuiltin,
//      PRVUnsignedReductionBuiltin;
//
//// For widen operation which has different mangling name.
//multiclass PRVWidenBuiltinSet<string intrinsic_name, string type_range,
//                              list<list<string>> suffixes_prototypes> {
//  let Log2LMUL = [-3, -2, -1, 0, 1, 2],
//      IRName = intrinsic_name, IRNameMask = intrinsic_name # "_mask" in {
//    foreach s_p = suffixes_prototypes in {
//      let Name = NAME # "_" # s_p[0],
//          MangledName = NAME # "_" # s_p[0] in {
//        defvar suffix = s_p[1];
//        defvar prototype = s_p[2];
//        def : PRVOutOp0Op1Builtin<suffix, prototype, type_range>;
//      }
//    }
//  }
//}
//
//// For widen operation with widen operand which has different mangling name.
//multiclass PRVWidenWOp0BuiltinSet<string intrinsic_name, string type_range,
//                                  list<list<string>> suffixes_prototypes> {
//  let Log2LMUL = [-3, -2, -1, 0, 1, 2],
//      IRName = intrinsic_name, IRNameMask = intrinsic_name # "_mask" in {
//    foreach s_p = suffixes_prototypes in {
//      let Name = NAME # "_" # s_p[0],
//          MangledName = NAME # "_" # s_p[0] in {
//        defvar suffix = s_p[1];
//        defvar prototype = s_p[2];
//        def : PRVOutOp1Builtin<suffix, prototype, type_range>;
//      }
//    }
//  }
//}
//
//multiclass PRVSignedWidenBinBuiltinSet
//    : PRVWidenBuiltinSet<NAME, "csi",
//                         [["vv", "w", "wvv"],
//                          ["vx", "w", "wve"]]>;
//
//multiclass PRVSignedWidenOp0BinBuiltinSet
//    : PRVWidenWOp0BuiltinSet<NAME # "_w", "csi",
//                             [["wv", "w", "wwv"],
//                              ["wx", "w", "wwe"]]>;
//
//multiclass PRVUnsignedWidenBinBuiltinSet
//    : PRVWidenBuiltinSet<NAME, "csi",
//                         [["vv", "Uw", "UwUvUv"],
//                          ["vx", "Uw", "UwUvUe"]]>;
//
//multiclass PRVUnsignedWidenOp0BinBuiltinSet
//    : PRVWidenWOp0BuiltinSet<NAME # "_w", "csi",
//                             [["wv", "Uw", "UwUwUv"],
//                              ["wx", "Uw", "UwUwUe"]]>;
//
//multiclass PRVFloatingWidenBinBuiltinSet
//    : PRVWidenBuiltinSet<NAME, "xf",
//                         [["vv", "w", "wvv"],
//                          ["vf", "w", "wve"]]>;
//
//multiclass PRVFloatingWidenOp0BinBuiltinSet
//    : PRVWidenWOp0BuiltinSet<NAME # "_w", "xf",
//                             [["wv", "w", "wwv"],
//                              ["wf", "w", "wwe"]]>;
//
//defvar TypeList = ["c","s","i","l","x","f","d"];
//defvar EEWList = [["8", "(Log2EEW:3)"],
//                  ["16", "(Log2EEW:4)"],
//                  ["32", "(Log2EEW:5)"],
//                  ["64", "(Log2EEW:6)"]];
//
//class IsFloat<string type> {
//  bit val = !or(!eq(type, "x"), !eq(type, "f"), !eq(type, "d"));
//}
//
//let HasNoMaskedOverloaded = false,
//    ManualCodegen = [{
//      IntrinsicTypes = {ResultType, Ops[1]->getType()};
//      Ops[0] = Builder.CreateBitCast(Ops[0], ResultType->getPointerTo());
//    }],
//    ManualCodegenMask= [{
//      // Move mask to right before vl.
//      std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//      IntrinsicTypes = {ResultType, Ops[3]->getType()};
//      Ops[1] = Builder.CreateBitCast(Ops[1], ResultType->getPointerTo());
//    }] in {
//  class PRVVLEMaskBuiltin : PRVBuiltin<"m", "mPCUe", "c"> {
//    let Name = "vle1_v";
//    let IRName = "vle1";
//    let HasMask = false;
//  }
//  multiclass PRVVLEBuiltin<list<string> types> {
//    let Name = NAME # "_v",
//        IRName = "vle",
//        IRNameMask ="vle_mask" in {
//      foreach type = types in {
//        def : PRVBuiltin<"v", "vPCe", type>;
//        if !not(IsFloat<type>.val) then {
//          def : PRVBuiltin<"Uv", "UvPCUe", type>;
//        }
//      }
//    }
//  }
//}
//
//multiclass PRVVLEFFBuiltin<list<string> types> {
//  let Name = NAME # "_v",
//      IRName = "vleff",
//      IRNameMask = "vleff_mask",
//      HasNoMaskedOverloaded = false,
//      ManualCodegen = [{
//      {
//        IntrinsicTypes = {ResultType, Ops[2]->getType()};
//        Ops[0] = Builder.CreateBitCast(Ops[0], ResultType->getPointerTo());
//        Value *NewVL = Ops[1];
//        Ops.erase(Ops.begin() + 1);
//        llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//        llvm::Value *LoadValue = Builder.CreateCall(F, Ops, "");
//        llvm::Value *V = Builder.CreateExtractValue(LoadValue, {0});
//        // Store new_vl.
//        clang::CharUnits Align =
//            CGM.getNaturalTypeAlignment(getContext().getSizeType());
//        Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {1}),
//                            Address(NewVL, Align));
//        return V;
//      }
//      }],
//      ManualCodegenMask = [{
//      {
//        // Move mask to right before vl.
//        std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//        IntrinsicTypes = {ResultType, Ops[4]->getType()};
//        Ops[1] = Builder.CreateBitCast(Ops[1], ResultType->getPointerTo());
//        Value *NewVL = Ops[2];
//        Ops.erase(Ops.begin() + 2);
//        llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//        llvm::Value *LoadValue = Builder.CreateCall(F, Ops, "");
//        llvm::Value *V = Builder.CreateExtractValue(LoadValue, {0});
//        // Store new_vl.
//        clang::CharUnits Align =
//            CGM.getNaturalTypeAlignment(getContext().getSizeType());
//        Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {1}),
//                            Address(NewVL, Align));
//        return V;
//      }
//      }] in {
//    foreach type = types in {
//      def : PRVBuiltin<"v", "vPCePz", type>;
//      // Skip floating types for unsigned versions.
//      if !not(IsFloat<type>.val) then {
//        def : PRVBuiltin<"Uv", "UvPCUePz", type>;
//      }
//    }
//  }
//}
//
//multiclass PRVVLSEBuiltin<list<string> types> {
//  let Name = NAME # "_v",
//      IRName = "vlse",
//      IRNameMask ="vlse_mask",
//      HasNoMaskedOverloaded = false,
//      ManualCodegen = [{
//        IntrinsicTypes = {ResultType, Ops[2]->getType()};
//        Ops[0] = Builder.CreateBitCast(Ops[0], ResultType->getPointerTo());
//      }],
//      ManualCodegenMask= [{
//        // Move mask to right before vl.
//        std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//        IntrinsicTypes = {ResultType, Ops[4]->getType()};
//        Ops[1] = Builder.CreateBitCast(Ops[1], ResultType->getPointerTo());
//      }] in {
//    foreach type = types in {
//      def : PRVBuiltin<"v", "vPCet", type>;
//      if !not(IsFloat<type>.val) then {
//        def : PRVBuiltin<"Uv", "UvPCUet", type>;
//      }
//    }
//  }
//}
//
//multiclass PRVIndexedLoad<string op> {
//  let ManualCodegen = [{
//        IntrinsicTypes = {ResultType, Ops[1]->getType(), Ops[2]->getType()};
//        Ops[0] = Builder.CreateBitCast(Ops[0], ResultType->getPointerTo());
//      }],
//      ManualCodegenMask = [{
//        // Move mask to right before vl.
//        std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//        IntrinsicTypes = {ResultType, Ops[2]->getType(), Ops[4]->getType()};
//        Ops[1] = Builder.CreateBitCast(Ops[1], ResultType->getPointerTo());
//      }] in {
//      foreach type = TypeList in {
//        foreach eew_list = EEWList in {
//          defvar eew = eew_list[0];
//          defvar eew_type = eew_list[1];
//          let Name = op # eew # "_v", IRName = op, IRNameMask = op # "_mask" in {
//            def: PRVBuiltin<"v", "vPCe" # eew_type # "Uv", type>;
//              if !not(IsFloat<type>.val) then {
//                def: PRVBuiltin<"Uv", "UvPCUe" # eew_type # "Uv", type>;
//              }
//          }
//        }
//      }
//  }
//}
//
//let HasMaskedOffOperand = false,
//    ManualCodegen = [{
//      // Builtin: (ptr, value, vl). Intrinsic: (value, ptr, vl)
//      std::swap(Ops[0], Ops[1]);
//      Ops[1] = Builder.CreateBitCast(Ops[1], Ops[0]->getType()->getPointerTo());
//      IntrinsicTypes = {Ops[0]->getType(), Ops[2]->getType()};
//    }],
//    ManualCodegenMask= [{
//      // Builtin: (mask, ptr, value, vl). Intrinsic: (value, ptr, mask, vl)
//      std::swap(Ops[0], Ops[2]);
//      Ops[1] = Builder.CreateBitCast(Ops[1], Ops[0]->getType()->getPointerTo());
//      IntrinsicTypes = {Ops[0]->getType(), Ops[3]->getType()};
//    }] in {
//  class PRVVSEMaskBuiltin : PRVBuiltin<"m", "0PUem", "c"> {
//    let Name = "vse1_v";
//    let IRName = "vse1";
//    let HasMask = false;
//  }
//  multiclass PRVVSEBuiltin<list<string> types> {
//    let Name = NAME # "_v",
//        IRName = "vse",
//        IRNameMask = "vse_mask" in {
//      foreach type = types in {
//        def : PRVBuiltin<"v", "0Pev", type>;
//        if !not(IsFloat<type>.val) then {
//          def : PRVBuiltin<"Uv", "0PUeUv", type>;
//        }
//      }
//    }
//  }
//}
//
//multiclass PRVVSSEBuiltin<list<string> types> {
//  let Name = NAME # "_v",
//      IRName = "vsse",
//      IRNameMask = "vsse_mask",
//      HasMaskedOffOperand = false,
//      ManualCodegen = [{
//        // Builtin: (ptr, stride, value, vl). Intrinsic: (value, ptr, stride, vl)
//        std::rotate(Ops.begin(), Ops.begin() + 2, Ops.begin() + 3);
//        Ops[1] = Builder.CreateBitCast(Ops[1], Ops[0]->getType()->getPointerTo());
//        IntrinsicTypes = {Ops[0]->getType(), Ops[3]->getType()};
//      }],
//      ManualCodegenMask= [{
//        // Builtin: (mask, ptr, stride, value, vl). Intrinsic: (value, ptr, stride, mask, vl)
//        std::swap(Ops[0], Ops[3]);
//        Ops[1] = Builder.CreateBitCast(Ops[1], Ops[0]->getType()->getPointerTo());
//        IntrinsicTypes = {Ops[0]->getType(), Ops[4]->getType()};
//      }] in {
//    foreach type = types in {
//      def : PRVBuiltin<"v", "0Petv", type>;
//      if !not(IsFloat<type>.val) then {
//        def : PRVBuiltin<"Uv", "0PUetUv", type>;
//      }
//    }
//  }
//}
//
//multiclass PRVIndexedStore<string op> {
//  let HasMaskedOffOperand = false,
//      ManualCodegen = [{
//        // Builtin: (ptr, index, value, vl). Intrinsic: (value, ptr, index, vl)
//        std::rotate(Ops.begin(), Ops.begin() + 2, Ops.begin() + 3);
//        Ops[1] = Builder.CreateBitCast(Ops[1],Ops[0]->getType()->getPointerTo());
//        IntrinsicTypes = {Ops[0]->getType(), Ops[2]->getType(), Ops[3]->getType()};
//      }],
//      ManualCodegenMask= [{
//        // Builtin: (mask, ptr, index, value, vl). Intrinsic: (value, ptr, index, mask, vl)
//        std::swap(Ops[0], Ops[3]);
//        Ops[1] = Builder.CreateBitCast(Ops[1], Ops[0]->getType()->getPointerTo());
//        IntrinsicTypes = {Ops[0]->getType(), Ops[2]->getType(), Ops[4]->getType()};
//      }] in {
//      foreach type = TypeList in {
//        foreach eew_list = EEWList in {
//          defvar eew = eew_list[0];
//          defvar eew_type = eew_list[1];
//          let Name = op # eew  # "_v", IRName = op, IRNameMask = op # "_mask" in  {
//            def : PRVBuiltin<"v", "0Pe" # eew_type # "Uvv", type>;
//            if !not(IsFloat<type>.val) then {
//              def : PRVBuiltin<"Uv", "0PUe" # eew_type # "UvUv", type>;
//            }
//          }
//        }
//      }
//  }
//}
//
//defvar NFList = [2, 3, 4, 5, 6, 7, 8];
//
//class PVString<int nf, bit signed> {
//  string S =
//    !cond(!eq(nf, 2): !if(signed, "PvPv", "PUvPUv"),
//          !eq(nf, 3): !if(signed, "PvPvPv", "PUvPUvPUv"),
//          !eq(nf, 4): !if(signed, "PvPvPvPv", "PUvPUvPUvPUv"),
//          !eq(nf, 5): !if(signed, "PvPvPvPvPv", "PUvPUvPUvPUvPUv"),
//          !eq(nf, 6): !if(signed, "PvPvPvPvPvPv", "PUvPUvPUvPUvPUvPUv"),
//          !eq(nf, 7): !if(signed, "PvPvPvPvPvPvPv", "PUvPUvPUvPUvPUvPUvPUv"),
//          !eq(nf, 8): !if(signed, "PvPvPvPvPvPvPvPv", "PUvPUvPUvPUvPUvPUvPUvPUv"));
//}
//
//multiclass PRVUnitStridedSegLoad<string op> {
//  foreach type = TypeList in {
//    defvar eew = !cond(!eq(type, "c") : "8",
//                       !eq(type, "s") : "16",
//                       !eq(type, "i") : "32",
//                       !eq(type, "l") : "64",
//                       !eq(type, "x") : "16",
//                       !eq(type, "f") : "32",
//                       !eq(type, "d") : "64");
//      foreach nf = NFList in {
//        let Name = op # nf # "e" # eew # "_v",
//            IRName = op # nf,
//            IRNameMask = op # nf # "_mask",
//            NF = nf,
//            HasNoMaskedOverloaded = false,
//            ManualCodegen = [{
//    {
//      // builtin: (val0 address, val1 address, ..., ptr, vl)
//      IntrinsicTypes = {Ops[0]->getType()->getPointerElementType(),
//                        Ops[NF + 1]->getType()};
//      // intrinsic: (ptr, vl)
//      llvm::Value *Operands[] = {Ops[NF], Ops[NF + 1]};
//      llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//      llvm::Value *LoadValue = Builder.CreateCall(F, Operands, "");
//      clang::CharUnits Align = CharUnits::fromQuantity(
//                                 IntrinsicTypes[0]->getScalarSizeInBits() / 8);
//      llvm::Value *V;
//      for (unsigned I = 0; I < NF; ++I) {
//        V = Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {I}),
//                                Address(Ops[I], Align));
//      }
//      return V;
//    }
//            }],
//            ManualCodegenMask = [{
//    {
//      // builtin: (val0 address, ..., mask, maskedoff0, ..., ptr, vl)
//      // intrinsic: (maskedoff0, ..., ptr, mask, vl)
//      IntrinsicTypes = {Ops[0]->getType()->getPointerElementType(),
//                        Ops[2 * NF + 2]->getType()};
//      SmallVector<llvm::Value*, 12> Operands;
//      for (unsigned I = 0; I < NF; ++I)
//        Operands.push_back(Ops[NF + I + 1]);
//      Operands.push_back(Ops[2 * NF + 1]);
//      Operands.push_back(Ops[NF]);
//      Operands.push_back(Ops[2 * NF + 2]);
//      assert(Operands.size() == NF + 3);
//      llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//      llvm::Value *LoadValue = Builder.CreateCall(F, Operands, "");
//      clang::CharUnits Align = CharUnits::fromQuantity(
//                                 IntrinsicTypes[0]->getScalarSizeInBits() / 8);
//      llvm::Value *V;
//      for (unsigned I = 0; I < NF; ++I) {
//        V = Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {I}),
//                                Address(Ops[I], Align));
//      }
//      return V;
//    }
//            }] in {
//          defvar PV = PVString<nf, /*signed=*/true>.S;
//          defvar PUV = PVString<nf, /*signed=*/false>.S;
//          def : PRVBuiltin<"v", "0" # PV # "PCe", type>;
//          if !not(IsFloat<type>.val) then {
//            def : PRVBuiltin<"Uv", "0" # PUV # "PCUe", type>;
//        }
//      }
//    }
//  }
//}
//
//multiclass PRVUnitStridedSegLoadFF<string op> {
//  foreach type = TypeList in {
//    defvar eew = !cond(!eq(type, "c") : "8",
//                       !eq(type, "s") : "16",
//                       !eq(type, "i") : "32",
//                       !eq(type, "l") : "64",
//                       !eq(type, "x") : "16",
//                       !eq(type, "f") : "32",
//                       !eq(type, "d") : "64");
//      foreach nf = NFList in {
//        let Name = op # nf # "e" # eew # "ff_v",
//            IRName = op # nf # "ff",
//            IRNameMask = op # nf # "ff_mask",
//            NF = nf,
//            HasNoMaskedOverloaded = false,
//            ManualCodegen = [{
//    {
//      // builtin: (val0 address, val1 address, ..., ptr, new_vl, vl)
//      IntrinsicTypes = {Ops[0]->getType()->getPointerElementType(),
//                        Ops[NF + 2]->getType()};
//      // intrinsic: (ptr, vl)
//      llvm::Value *Operands[] = {Ops[NF], Ops[NF + 2]};
//      Value *NewVL = Ops[NF + 1];
//      llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//      llvm::Value *LoadValue = Builder.CreateCall(F, Operands, "");
//      clang::CharUnits Align = CharUnits::fromQuantity(
//                                 IntrinsicTypes[0]->getScalarSizeInBits() / 8);
//      for (unsigned I = 0; I < NF; ++I) {
//        Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {I}),
//                            Address(Ops[I], Align));
//      }
//      // Store new_vl.
//      return Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {NF}),
//                                 Address(NewVL, Align));
//    }
//            }],
//            ManualCodegenMask = [{
//    {
//      // builtin: (val0 address, ..., mask, maskedoff0, ..., ptr, new_vl, vl)
//      // intrinsic: (maskedoff0, ..., ptr, mask, vl)
//      IntrinsicTypes = {Ops[0]->getType()->getPointerElementType(),
//                        Ops[2 * NF + 3]->getType()};
//      SmallVector<llvm::Value*, 12> Operands;
//      for (unsigned I = 0; I < NF; ++I)
//        Operands.push_back(Ops[NF + I + 1]);
//      Operands.push_back(Ops[2 * NF + 1]);
//      Operands.push_back(Ops[NF]);
//      Operands.push_back(Ops[2 * NF + 3]);
//      Value *NewVL = Ops[2 * NF + 2];
//      assert(Operands.size() == NF + 3);
//      llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//      llvm::Value *LoadValue = Builder.CreateCall(F, Operands, "");
//      clang::CharUnits Align = CharUnits::fromQuantity(
//                                 IntrinsicTypes[0]->getScalarSizeInBits() / 8);
//      for (unsigned I = 0; I < NF; ++I) {
//        Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {I}),
//                            Address(Ops[I], Align));
//      }
//      // Store new_vl.
//      return Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {NF}),
//                                 Address(NewVL, Align));
//    }
//            }] in {
//          defvar PV = PVString<nf, /*signed=*/true>.S;
//          defvar PUV = PVString<nf, /*signed=*/false>.S;
//          def : PRVBuiltin<"v", "0" # PV # "PCe" # "Pz", type>;
//          if !not(IsFloat<type>.val) then {
//            def : PRVBuiltin<"Uv", "0" # PUV # "PCUe" # "Pz", type>;
//        }
//      }
//    }
//  }
//}
//
//multiclass PRVStridedSegLoad<string op> {
//  foreach type = TypeList in {
//    defvar eew = !cond(!eq(type, "c") : "8",
//                       !eq(type, "s") : "16",
//                       !eq(type, "i") : "32",
//                       !eq(type, "l") : "64",
//                       !eq(type, "x") : "16",
//                       !eq(type, "f") : "32",
//                       !eq(type, "d") : "64");
//      foreach nf = NFList in {
//        let Name = op # nf # "e" # eew # "_v",
//            IRName = op # nf,
//            IRNameMask = op # nf # "_mask",
//            NF = nf,
//            HasNoMaskedOverloaded = false,
//            ManualCodegen = [{
//    {
//      // builtin: (val0 address, val1 address, ..., ptr, stride, vl)
//      IntrinsicTypes = {Ops[0]->getType()->getPointerElementType(),
//                        Ops[NF + 2]->getType()};
//      // intrinsic: (ptr, stride, vl)
//      llvm::Value *Operands[] = {Ops[NF], Ops[NF + 1], Ops[NF + 2]};
//      llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//      llvm::Value *LoadValue = Builder.CreateCall(F, Operands, "");
//      clang::CharUnits Align = CharUnits::fromQuantity(
//                                 IntrinsicTypes[0]->getScalarSizeInBits() / 8);
//      llvm::Value *V;
//      for (unsigned I = 0; I < NF; ++I) {
//        V = Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {I}),
//                                Address(Ops[I], Align));
//      }
//      return V;
//    }
//            }],
//            ManualCodegenMask = [{
//    {
//      // builtin: (val0 address, ..., mask, maskedoff0, ..., ptr, stride, vl)
//      // intrinsic: (maskedoff0, ..., ptr, stride, mask, vl)
//      IntrinsicTypes = {Ops[0]->getType()->getPointerElementType(),
//                        Ops[2 * NF + 3]->getType()};
//      SmallVector<llvm::Value*, 12> Operands;
//      for (unsigned I = 0; I < NF; ++I)
//        Operands.push_back(Ops[NF + I + 1]);
//      Operands.push_back(Ops[2 * NF + 1]);
//      Operands.push_back(Ops[2 * NF + 2]);
//      Operands.push_back(Ops[NF]);
//      Operands.push_back(Ops[2 * NF + 3]);
//      assert(Operands.size() == NF + 4);
//      llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//      llvm::Value *LoadValue = Builder.CreateCall(F, Operands, "");
//      clang::CharUnits Align = CharUnits::fromQuantity(
//                                 IntrinsicTypes[0]->getScalarSizeInBits() / 8);
//      llvm::Value *V;
//      for (unsigned I = 0; I < NF; ++I) {
//        V = Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {I}),
//                                Address(Ops[I], Align));
//      }
//      return V;
//    }
//            }] in {
//          defvar PV = PVString<nf, /*signed=*/true>.S;
//          defvar PUV = PVString<nf, /*signed=*/false>.S;
//          def : PRVBuiltin<"v", "0" # PV # "PCe" # "t", type>;
//          if !not(IsFloat<type>.val) then {
//            def : PRVBuiltin<"Uv", "0" # PUV # "PCUe" # "t", type>;
//        }
//      }
//    }
//  }
//}
//
//multiclass PRVIndexedSegLoad<string op> {
//  foreach type = TypeList in {
//    foreach eew_info = EEWList in {
//      defvar eew = eew_info[0];
//      defvar eew_type = eew_info[1];
//      foreach nf = NFList in {
//        let Name = op # nf # "ei" # eew # "_v",
//            IRName = op # nf,
//            IRNameMask = op # nf # "_mask",
//            NF = nf,
//            ManualCodegen = [{
//    {
//      // builtin: (val0 address, val1 address, ..., ptr, index, vl)
//      IntrinsicTypes = {Ops[0]->getType()->getPointerElementType(),
//                        Ops[NF + 1]->getType(), Ops[NF + 2]->getType()};
//      // intrinsic: (ptr, index, vl)
//      llvm::Value *Operands[] = {Ops[NF], Ops[NF + 1], Ops[NF + 2]};
//      llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//      llvm::Value *LoadValue = Builder.CreateCall(F, Operands, "");
//      clang::CharUnits Align = CharUnits::fromQuantity(
//                                 IntrinsicTypes[0]->getScalarSizeInBits() / 8);
//      llvm::Value *V;
//      for (unsigned I = 0; I < NF; ++I) {
//        V = Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {I}),
//                                Address(Ops[I], Align));
//      }
//      return V;
//    }
//            }],
//            ManualCodegenMask = [{
//    {
//      // builtin: (val0 address, ..., mask, maskedoff0, ..., ptr, index, vl)
//      IntrinsicTypes = {Ops[0]->getType()->getPointerElementType(),
//                        Ops[2 * NF + 2]->getType(), Ops[2 * NF + 3]->getType()};
//      // intrinsic: (maskedoff0, ..., ptr, index, mask, vl)
//      SmallVector<llvm::Value*, 12> Operands;
//      for (unsigned I = 0; I < NF; ++I)
//        Operands.push_back(Ops[NF + I + 1]);
//      Operands.push_back(Ops[2 * NF + 1]);
//      Operands.push_back(Ops[2 * NF + 2]);
//      Operands.push_back(Ops[NF]);
//      Operands.push_back(Ops[2 * NF + 3]);
//      assert(Operands.size() == NF + 4);
//      llvm::Function *F = CGM.getIntrinsic(ID, IntrinsicTypes);
//      llvm::Value *LoadValue = Builder.CreateCall(F, Operands, "");
//      clang::CharUnits Align = CharUnits::fromQuantity(
//                                 IntrinsicTypes[0]->getScalarSizeInBits() / 8);
//      llvm::Value *V;
//      for (unsigned I = 0; I < NF; ++I) {
//        V = Builder.CreateStore(Builder.CreateExtractValue(LoadValue, {I}),
//                                Address(Ops[I], Align));
//      }
//      return V;
//    }
//            }] in {
//          defvar PV = PVString<nf, /*signed=*/true>.S;
//          defvar PUV = PVString<nf, /*signed=*/false>.S;
//          def : PRVBuiltin<"v", "0" # PV # "PCe" # eew_type # "Uv", type>;
//          if !not(IsFloat<type>.val) then {
//            def : PRVBuiltin<"Uv", "0" # PUV # "PCUe" # eew_type # "Uv", type>;
//          }
//        }
//      }
//    }
//  }
//}
//
//class VString<int nf, bit signed> {
//  string S = !cond(!eq(nf, 2): !if(signed, "vv", "UvUv"),
//                   !eq(nf, 3): !if(signed, "vvv", "UvUvUv"),
//                   !eq(nf, 4): !if(signed, "vvvv", "UvUvUvUv"),
//                   !eq(nf, 5): !if(signed, "vvvvv", "UvUvUvUvUv"),
//                   !eq(nf, 6): !if(signed, "vvvvvv", "UvUvUvUvUvUv"),
//                   !eq(nf, 7): !if(signed, "vvvvvvv", "UvUvUvUvUvUvUv"),
//                   !eq(nf, 8): !if(signed, "vvvvvvvv", "UvUvUvUvUvUvUvUv"));
//}
//
//multiclass PRVUnitStridedSegStore<string op> {
//  foreach type = TypeList in {
//    defvar eew = !cond(!eq(type, "c") : "8",
//                       !eq(type, "s") : "16",
//                       !eq(type, "i") : "32",
//                       !eq(type, "l") : "64",
//                       !eq(type, "x") : "16",
//                       !eq(type, "f") : "32",
//                       !eq(type, "d") : "64");
//      foreach nf = NFList in {
//        let Name = op # nf # "e" # eew # "_v",
//            IRName = op # nf,
//            IRNameMask = op # nf # "_mask",
//            NF = nf,
//            HasMaskedOffOperand = false,
//            ManualCodegen = [{
//    {
//      // Builtin: (ptr, val0, val1, ..., vl)
//      // Intrinsic: (val0, val1, ..., ptr, vl)
//      std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//      IntrinsicTypes = {Ops[0]->getType(), Ops[NF + 1]->getType()};
//      assert(Ops.size() == NF + 2);
//    }
//            }],
//            ManualCodegenMask = [{
//    {
//      // Builtin: (mask, ptr, val0, val1, ..., vl)
//      // Intrinsic: (val0, val1, ..., ptr, mask, vl)
//      std::rotate(Ops.begin(), Ops.begin() + 2, Ops.end() - 1);
//      std::swap(Ops[NF], Ops[NF + 1]);
//      IntrinsicTypes = {Ops[0]->getType(), Ops[NF + 2]->getType()};
//      assert(Ops.size() == NF + 3);
//    }
//            }] in {
//          defvar V = VString<nf, /*signed=*/true>.S;
//          defvar UV = VString<nf, /*signed=*/false>.S;
//          def : PRVBuiltin<"v", "0Pe" # V, type>;
//          if !not(IsFloat<type>.val) then {
//            def : PRVBuiltin<"Uv", "0PUe" # UV, type>;
//        }
//      }
//    }
//  }
//}
//
//multiclass PRVStridedSegStore<string op> {
//  foreach type = TypeList in {
//    defvar eew = !cond(!eq(type, "c") : "8",
//                       !eq(type, "s") : "16",
//                       !eq(type, "i") : "32",
//                       !eq(type, "l") : "64",
//                       !eq(type, "x") : "16",
//                       !eq(type, "f") : "32",
//                       !eq(type, "d") : "64");
//      foreach nf = NFList in {
//        let Name = op # nf # "e" # eew # "_v",
//            IRName = op # nf,
//            IRNameMask = op # nf # "_mask",
//            NF = nf,
//            HasMaskedOffOperand = false,
//            ManualCodegen = [{
//    {
//      // Builtin: (ptr, stride, val0, val1, ..., vl).
//      // Intrinsic: (val0, val1, ..., ptr, stride, vl)
//      std::rotate(Ops.begin(), Ops.begin() + 2, Ops.end() - 1);
//      IntrinsicTypes = {Ops[0]->getType(), Ops[NF + 1]->getType()};
//      assert(Ops.size() == NF + 3);
//    }
//            }],
//            ManualCodegenMask = [{
//    {
//      // Builtin: (mask, ptr, stride, val0, val1, ..., vl).
//      // Intrinsic: (val0, val1, ..., ptr, stride, mask, vl)
//      std::rotate(Ops.begin(), Ops.begin() + 3, Ops.end() - 1);
//      std::rotate(Ops.begin() + NF, Ops.begin() + NF + 1, Ops.begin() + NF + 3);
//      IntrinsicTypes = {Ops[0]->getType(), Ops[NF + 1]->getType()};
//      assert(Ops.size() == NF + 4);
//    }
//            }] in {
//          defvar V = VString<nf, /*signed=*/true>.S;
//          defvar UV = VString<nf, /*signed=*/false>.S;
//          def : PRVBuiltin<"v", "0Pet" # V, type>;
//          if !not(IsFloat<type>.val) then {
//            def : PRVBuiltin<"Uv", "0PUet" # UV, type>;
//        }
//      }
//    }
//  }
//}
//
//multiclass PRVIndexedSegStore<string op> {
//  foreach type = TypeList in {
//    foreach eew_info = EEWList in {
//      defvar eew = eew_info[0];
//      defvar eew_type = eew_info[1];
//      foreach nf = NFList in {
//        let Name = op # nf # "ei" # eew # "_v",
//            IRName = op # nf,
//            IRNameMask = op # nf # "_mask",
//            NF = nf,
//            HasMaskedOffOperand = false,
//            ManualCodegen = [{
//    {
//      // Builtin: (ptr, index, val0, val1, ..., vl)
//      // Intrinsic: (val0, val1, ..., ptr, index, vl)
//      std::rotate(Ops.begin(), Ops.begin() + 2, Ops.end() - 1);
//      IntrinsicTypes = {Ops[0]->getType(),
//                        Ops[NF + 1]->getType(), Ops[NF + 2]->getType()};
//      assert(Ops.size() == NF + 3);
//    }
//            }],
//            ManualCodegenMask = [{
//    {
//      // Builtin: (mask, ptr, index, val0, val1, ..., vl)
//      // Intrinsic: (val0, val1, ..., ptr, index, mask, vl)
//      std::rotate(Ops.begin(), Ops.begin() + 3, Ops.end() - 1);
//      std::rotate(Ops.begin() + NF, Ops.begin() + NF + 1, Ops.begin() + NF + 3);
//      IntrinsicTypes = {Ops[0]->getType(),
//                        Ops[NF + 1]->getType(), Ops[NF + 3]->getType()};
//      assert(Ops.size() == NF + 4);
//    }
//            }] in {
//          defvar V = VString<nf, /*signed=*/true>.S;
//          defvar UV = VString<nf, /*signed=*/false>.S;
//          def : PRVBuiltin<"v", "0Pe" # eew_type # "Uv" # V, type>;
//          if !not(IsFloat<type>.val) then {
//            def : PRVBuiltin<"Uv", "0PUe" # eew_type # "Uv" # UV, type>;
//          }
//        }
//      }
//    }
//  }
//}
//
//multiclass PRVAMOBuiltinSet<bit has_signed = false, bit has_unsigned = false,
//                            bit has_fp = false> {
//  defvar type_list = !if(has_fp, ["i","l","f","d"], ["i","l"]);
//  foreach type = type_list in
//    foreach eew_list = EEWList in {
//      defvar eew = eew_list[0];
//      defvar eew_index = eew_list[1];
//      let Name = NAME # "ei" # eew # "_" # "v",
//          IRName = NAME,
//          IRNameMask = NAME # "_mask",
//          HasMaskedOffOperand = false,
//          ManualCodegen = [{
//            // base, bindex, value, vl
//            IntrinsicTypes = {ResultType, Ops[1]->getType(), Ops[3]->getType()};
//            Ops[0] = Builder.CreateBitCast(Ops[0], ResultType->getPointerTo());
//          }],
//          ManualCodegenMask = [{
//            std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//            IntrinsicTypes = {ResultType, Ops[1]->getType(), Ops[4]->getType()};
//            Ops[0] = Builder.CreateBitCast(Ops[0], ResultType->getPointerTo());
//          }] in {
//        if has_signed then
//          def : PRVBuiltin<"v", "vPe" # eew_index # "Uvv", type>;
//        if !and(!not(IsFloat<type>.val), has_unsigned) then
//          def : PRVBuiltin<"Uv", "UvPUe" # eew_index # "UvUv", type>;
//      }
//    }
//}
//
//multiclass PRVPseudoUnaryBuiltin<string IR, string type_range> {
//  let Name = NAME,
//      IRName = IR,
//      IRNameMask = IR # "_mask",
//      ManualCodegen = [{
//      {
//        // op1, vl
//        IntrinsicTypes = {ResultType,
//                          cast<llvm::VectorType>(ResultType)->getElementType(),
//                          Ops[1]->getType()};
//        Ops.insert(Ops.begin() + 1, llvm::Constant::getNullValue(IntrinsicTypes[1]));
//        break;
//      }
//      }],
//      ManualCodegenMask = [{
//      {
//        std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//        // maskedoff, op1, mask, vl
//        IntrinsicTypes = {ResultType,
//                          cast<llvm::VectorType>(ResultType)->getElementType(),
//                          Ops[3]->getType()};
//        Ops.insert(Ops.begin() + 2, llvm::Constant::getNullValue(IntrinsicTypes[1]));
//        break;
//      }
//      }] in {
//        def : PRVBuiltin<"v", "vv", type_range>;
//  }
//}
//
//multiclass PRVPseudoVNotBuiltin<string IR, string type_range> {
//  let Name = NAME,
//      IRName = IR,
//      IRNameMask = IR # "_mask",
//      ManualCodegen = [{
//      {
//        // op1, vl
//        IntrinsicTypes = {ResultType,
//                          cast<llvm::VectorType>(ResultType)->getElementType(),
//                          Ops[1]->getType()};
//        Ops.insert(Ops.begin() + 1,
//                   llvm::Constant::getAllOnesValue(IntrinsicTypes[1]));
//        break;
//      }
//      }],
//      ManualCodegenMask = [{
//      {
//        std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//        // maskedoff, op1, mask, vl
//        IntrinsicTypes = {ResultType,
//                          cast<llvm::VectorType>(ResultType)->getElementType(),
//                          Ops[3]->getType()};
//        Ops.insert(Ops.begin() + 2,
//                   llvm::Constant::getAllOnesValue(IntrinsicTypes[1]));
//        break;
//      }
//      }] in {
//        def : PRVBuiltin<"v", "vv", type_range>;
//        def : PRVBuiltin<"Uv", "UvUv", type_range>;
//  }
//}
//
//multiclass PRVPseudoMaskBuiltin<string IR, string type_range> {
//  let Name = NAME,
//      IRName = IR,
//      HasMask = false,
//      ManualCodegen = [{
//      {
//        // op1, vl
//        IntrinsicTypes = {ResultType,
//                          Ops[1]->getType()};
//        Ops.insert(Ops.begin() + 1, Ops[0]);
//        break;
//      }
//      }] in {
//        def : PRVBuiltin<"m", "mm", type_range>;
//  }
//}
//
//multiclass PRVPseudoVFUnaryBuiltin<string IR, string type_range> {
//  let Name = NAME,
//      IRName = IR,
//      IRNameMask = IR # "_mask",
//      ManualCodegen = [{
//      {
//        // op1, vl
//        IntrinsicTypes = {ResultType,
//                          Ops[0]->getType(), Ops[1]->getType()};
//        Ops.insert(Ops.begin() + 1, Ops[0]);
//        break;
//      }
//      }],
//      ManualCodegenMask = [{
//      {
//        std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//        // maskedoff, op1, mask, vl
//        IntrinsicTypes = {ResultType,
//                          Ops[1]->getType(),
//                          Ops[3]->getType()};
//        Ops.insert(Ops.begin() + 2, Ops[1]);
//        break;
//      }
//      }] in {
//        def : PRVBuiltin<"v", "vv", type_range>;
//  }
//}
//
//multiclass PRVPseudoVWCVTBuiltin<string IR, string MName, string type_range,
//                                 list<list<string>> suffixes_prototypes> {
//  let Name = NAME,
//      MangledName = MName,
//      IRName = IR,
//      IRNameMask = IR # "_mask",
//      ManualCodegen = [{
//      {
//        // op1, vl
//        IntrinsicTypes = {ResultType,
//                          Ops[0]->getType(),
//                          cast<llvm::VectorType>(Ops[0]->getType())->getElementType(),
//                          Ops[1]->getType()};
//        Ops.insert(Ops.begin() + 1, llvm::Constant::getNullValue(IntrinsicTypes[2]));
//        break;
//      }
//      }],
//      ManualCodegenMask = [{
//      {
//        std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//        // maskedoff, op1, mask, vl
//        IntrinsicTypes = {ResultType,
//                          Ops[1]->getType(),
//                          cast<llvm::VectorType>(Ops[1]->getType())->getElementType(),
//                          Ops[3]->getType()};
//        Ops.insert(Ops.begin() + 2, llvm::Constant::getNullValue(IntrinsicTypes[2]));
//        break;
//      }
//      }] in {
//        foreach s_p = suffixes_prototypes in {
//          def : PRVBuiltin<s_p[0], s_p[1], type_range>;
//        }
//  }
//}
//
//multiclass PRVPseudoVNCVTBuiltin<string IR, string MName, string type_range,
//                                 list<list<string>> suffixes_prototypes> {
//  let Name = NAME,
//      MangledName = MName,
//      IRName = IR,
//      IRNameMask = IR # "_mask",
//      ManualCodegen = [{
//      {
//        // op1, vl
//        IntrinsicTypes = {ResultType,
//                          Ops[0]->getType(),
//                          Ops[1]->getType(),
//                          Ops[1]->getType()};
//        Ops.insert(Ops.begin() + 1, llvm::Constant::getNullValue(IntrinsicTypes[2]));
//        break;
//      }
//      }],
//      ManualCodegenMask = [{
//      {
//        std::rotate(Ops.begin(), Ops.begin() + 1, Ops.end() - 1);
//        // maskedoff, op1, mask, vl
//        IntrinsicTypes = {ResultType,
//                          Ops[1]->getType(),
//                          Ops[3]->getType(),
//                          Ops[3]->getType()};
//        Ops.insert(Ops.begin() + 2, llvm::Constant::getNullValue(IntrinsicTypes[2]));
//        break;
//      }
//      }] in {
//        foreach s_p = suffixes_prototypes in {
//          def : PRVBuiltin<s_p[0], s_p[1], type_range>;
//        }
//  }
//}
//
//// 6. Configuration-Setting Instructions
//// 6.1. vsetvli/vsetvl instructions
//let HasVL = false,
//    HasMask = false,
//    HasSideEffects = true,
//    Log2LMUL = [0],
//    ManualCodegen = [{IntrinsicTypes = {ResultType};}] in // Set XLEN type
//{
//  // vsetvl is a macro because for it require constant integers in SEW and LMUL.
//  let HeaderCode =
//[{
//#define vsetvl_e8mf8(avl) __builtin_prv_vsetvli((size_t)(avl), 0, 5)
//#define vsetvl_e8mf4(avl) __builtin_prv_vsetvli((size_t)(avl), 0, 6)
//#define vsetvl_e8mf2(avl) __builtin_prv_vsetvli((size_t)(avl), 0, 7)
//#define vsetvl_e8m1(avl) __builtin_prv_vsetvli((size_t)(avl), 0, 0)
//#define vsetvl_e8m2(avl) __builtin_prv_vsetvli((size_t)(avl), 0, 1)
//#define vsetvl_e8m4(avl) __builtin_prv_vsetvli((size_t)(avl), 0, 2)
//#define vsetvl_e8m8(avl) __builtin_prv_vsetvli((size_t)(avl), 0, 3)
//
//#define vsetvl_e16mf4(avl) __builtin_prv_vsetvli((size_t)(avl), 1, 6)
//#define vsetvl_e16mf2(avl) __builtin_prv_vsetvli((size_t)(avl), 1, 7)
//#define vsetvl_e16m1(avl) __builtin_prv_vsetvli((size_t)(avl), 1, 0)
//#define vsetvl_e16m2(avl) __builtin_prv_vsetvli((size_t)(avl), 1, 1)
//#define vsetvl_e16m4(avl) __builtin_prv_vsetvli((size_t)(avl), 1, 2)
//#define vsetvl_e16m8(avl) __builtin_prv_vsetvli((size_t)(avl), 1, 3)
//
//#define vsetvl_e32mf2(avl) __builtin_prv_vsetvli((size_t)(avl), 2, 7)
//#define vsetvl_e32m1(avl) __builtin_prv_vsetvli((size_t)(avl), 2, 0)
//#define vsetvl_e32m2(avl) __builtin_prv_vsetvli((size_t)(avl), 2, 1)
//#define vsetvl_e32m4(avl) __builtin_prv_vsetvli((size_t)(avl), 2, 2)
//#define vsetvl_e32m8(avl) __builtin_prv_vsetvli((size_t)(avl), 2, 3)
//
//#define vsetvl_e64m1(avl) __builtin_prv_vsetvli((size_t)(avl), 3, 0)
//#define vsetvl_e64m2(avl) __builtin_prv_vsetvli((size_t)(avl), 3, 1)
//#define vsetvl_e64m4(avl) __builtin_prv_vsetvli((size_t)(avl), 3, 2)
//#define vsetvl_e64m8(avl) __builtin_prv_vsetvli((size_t)(avl), 3, 3)
//
//}] in
//  def vsetvli : PRVBuiltin<"", "zzKzKz", "i">;
//
//  let HeaderCode =
//[{
//#define vsetvlmax_e8mf8() __builtin_prv_vsetvlimax(0, 5)
//#define vsetvlmax_e8mf4() __builtin_prv_vsetvlimax(0, 6)
//#define vsetvlmax_e8mf2() __builtin_prv_vsetvlimax(0, 7)
//#define vsetvlmax_e8m1() __builtin_prv_vsetvlimax(0, 0)
//#define vsetvlmax_e8m2() __builtin_prv_vsetvlimax(0, 1)
//#define vsetvlmax_e8m4() __builtin_prv_vsetvlimax(0, 2)
//#define vsetvlmax_e8m8() __builtin_prv_vsetvlimax(0, 3)
//
//#define vsetvlmax_e16mf4() __builtin_prv_vsetvlimax(1, 6)
//#define vsetvlmax_e16mf2() __builtin_prv_vsetvlimax(1, 7)
//#define vsetvlmax_e16m1() __builtin_prv_vsetvlimax(1, 0)
//#define vsetvlmax_e16m2() __builtin_prv_vsetvlimax(1, 1)
//#define vsetvlmax_e16m4() __builtin_prv_vsetvlimax(1, 2)
//#define vsetvlmax_e16m8() __builtin_prv_vsetvlimax(1, 3)
//
//#define vsetvlmax_e32mf2() __builtin_prv_vsetvlimax(2, 7)
//#define vsetvlmax_e32m1() __builtin_prv_vsetvlimax(2, 0)
//#define vsetvlmax_e32m2() __builtin_prv_vsetvlimax(2, 1)
//#define vsetvlmax_e32m4() __builtin_prv_vsetvlimax(2, 2)
//#define vsetvlmax_e32m8() __builtin_prv_vsetvlimax(2, 3)
//
//#define vsetvlmax_e64m1() __builtin_prv_vsetvlimax(3, 0)
//#define vsetvlmax_e64m2() __builtin_prv_vsetvlimax(3, 1)
//#define vsetvlmax_e64m4() __builtin_prv_vsetvlimax(3, 2)
//#define vsetvlmax_e64m8() __builtin_prv_vsetvlimax(3, 3)
//
//}] in
//  def vsetvlimax : PRVBuiltin<"", "zKzKz", "i">;
//}
//
//// 7. Vector Loads and Stores
//// 7.4. Vector Unit-Stride Instructions
//def vle1: PRVVLEMaskBuiltin;
//defm vle8: PRVVLEBuiltin<["c"]>;
//defm vle16: PRVVLEBuiltin<["s","x"]>;
//defm vle32: PRVVLEBuiltin<["i","f"]>;
//defm vle64: PRVVLEBuiltin<["l","d"]>;
//
//def vse1 : PRVVSEMaskBuiltin;
//defm vse8 : PRVVSEBuiltin<["c"]>;
//defm vse16: PRVVSEBuiltin<["s","x"]>;
//defm vse32: PRVVSEBuiltin<["i","f"]>;
//defm vse64: PRVVSEBuiltin<["l","d"]>;
//
//// 7.5. Vector Strided Instructions
//defm vlse8: PRVVLSEBuiltin<["c"]>;
//defm vlse16: PRVVLSEBuiltin<["s","x"]>;
//defm vlse32: PRVVLSEBuiltin<["i","f"]>;
//defm vlse64: PRVVLSEBuiltin<["l","d"]>;
//
//defm vsse8 : PRVVSSEBuiltin<["c"]>;
//defm vsse16: PRVVSSEBuiltin<["s","x"]>;
//defm vsse32: PRVVSSEBuiltin<["i","f"]>;
//defm vsse64: PRVVSSEBuiltin<["l","d"]>;
//
//// 7.6. Vector Indexed Instructions
//defm : PRVIndexedLoad<"vluxei">;
//defm : PRVIndexedLoad<"vloxei">;
//
//defm : PRVIndexedStore<"vsuxei">;
//defm : PRVIndexedStore<"vsoxei">;
//
//// 7.7. Unit-stride Fault-Only-First Loads
//defm vle8ff: PRVVLEFFBuiltin<["c"]>;
//defm vle16ff: PRVVLEFFBuiltin<["s","x"]>;
//defm vle32ff: PRVVLEFFBuiltin<["i", "f"]>;
//defm vle64ff: PRVVLEFFBuiltin<["l", "d"]>;
//
//// 7.8 Vector Load/Store Segment Instructions
//let RequiredExtension = "Zvlsseg" in {
//defm : PRVUnitStridedSegLoad<"vlseg">;
//defm : PRVUnitStridedSegLoadFF<"vlseg">;
//defm : PRVStridedSegLoad<"vlsseg">;
//defm : PRVIndexedSegLoad<"vluxseg">;
//defm : PRVIndexedSegLoad<"vloxseg">;
//defm : PRVUnitStridedSegStore<"vsseg">;
//defm : PRVStridedSegStore<"vssseg">;
//defm : PRVIndexedSegStore<"vsuxseg">;
//defm : PRVIndexedSegStore<"vsoxseg">;
//}
//
//// 8. Vector AMO Operations
//let RequiredExtension = "Zvamo" in {
//defm vamoswap : PRVAMOBuiltinSet< /* hasSigned */ true, /* hasUnsigned */ true, /* hasFP */ true>;
//defm vamoadd : PRVAMOBuiltinSet< /* hasSigned */ true, /* hasUnsigned */ true>;
//defm vamoxor : PRVAMOBuiltinSet< /* hasSigned */ true, /* hasUnsigned */ true>;
//defm vamoand : PRVAMOBuiltinSet< /* hasSigned */ true, /* hasUnsigned */ true>;
//defm vamoor : PRVAMOBuiltinSet< /* hasSigned */ true, /* hasUnsigned */ true>;
//defm vamomin : PRVAMOBuiltinSet< /* hasSigned */ true>;
//defm vamomax : PRVAMOBuiltinSet< /* hasSigned */ true>;
//defm vamominu : PRVAMOBuiltinSet< /* hasSigned */ false, /* hasUnsigned */ true>;
//defm vamomaxu : PRVAMOBuiltinSet< /* hasSigned */ false, /* hasUnsigned */ true>;
//}
//
//// 12. Vector Integer Arithmetic Instructions
//// 12.1. Vector Single-Width Integer Add and Subtract
//defm vadd : PRVIntBinBuiltinSet;
//defm vsub : PRVIntBinBuiltinSet;
//defm vrsub : PRVOutOp1BuiltinSet<"vrsub", "csil",
//                                 [["vx", "v", "vve"],
//                                  ["vx", "Uv", "UvUvUe"]]>;
//defm vneg_v : PRVPseudoUnaryBuiltin<"vrsub", "csil">;
//
//// 12.2. Vector Widening Integer Add/Subtract
//// Widening unsigned integer add/subtract, 2*SEW = SEW +/- SEW
//defm vwaddu : PRVUnsignedWidenBinBuiltinSet;
//defm vwsubu : PRVUnsignedWidenBinBuiltinSet;
//// Widening signed integer add/subtract, 2*SEW = SEW +/- SEW
//defm vwadd : PRVSignedWidenBinBuiltinSet;
//defm vwsub : PRVSignedWidenBinBuiltinSet;
//// Widening unsigned integer add/subtract, 2*SEW = 2*SEW +/- SEW
//defm vwaddu : PRVUnsignedWidenOp0BinBuiltinSet;
//defm vwsubu : PRVUnsignedWidenOp0BinBuiltinSet;
//// Widening signed integer add/subtract, 2*SEW = 2*SEW +/- SEW
//defm vwadd : PRVSignedWidenOp0BinBuiltinSet;
//defm vwsub : PRVSignedWidenOp0BinBuiltinSet;
//defm vwcvtu_x_x_v : PRVPseudoVWCVTBuiltin<"vwaddu", "vwcvtu_x", "csi",
//                                          [["Uw", "UwUv"]]>;
//defm vwcvt_x_x_v : PRVPseudoVWCVTBuiltin<"vwadd", "vwcvt_x", "csi",
//                                         [["w", "wv"]]>;
//
//// 12.3. Vector Integer Extension
//let Log2LMUL = [-3, -2, -1, 0, 1, 2] in {
//  def vsext_vf2 : PRVIntExt<"vsext", "w", "wv", "csi">;
//  def vzext_vf2 : PRVIntExt<"vzext", "Uw", "UwUv", "csi">;
//}
//let Log2LMUL = [-3, -2, -1, 0, 1] in {
//  def vsext_vf4 : PRVIntExt<"vsext", "q", "qv", "cs">;
//  def vzext_vf4 : PRVIntExt<"vzext", "Uq", "UqUv", "cs">;
//}
//let Log2LMUL = [-3, -2, -1, 0] in {
//  def vsext_vf8 : PRVIntExt<"vsext", "o", "ov", "c">;
//  def vzext_vf8 : PRVIntExt<"vzext", "Uo", "UoUv", "c">;
//}
//
//// 12.4. Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions
//let HasMask = false in {
//  defm vadc : PRVCarryinBuiltinSet;
//  defm vmadc : PRVCarryOutInBuiltinSet<"vmadc_carry_in">;
//  defm vmadc : PRVIntMaskOutBuiltinSet;
//  defm vsbc : PRVCarryinBuiltinSet;
//  defm vmsbc : PRVCarryOutInBuiltinSet<"vmsbc_borrow_in">;
//  defm vmsbc : PRVIntMaskOutBuiltinSet;
//}
//
//// 12.5. Vector Bitwise Logical Instructions
//defm vand : PRVIntBinBuiltinSet;
//defm vxor : PRVIntBinBuiltinSet;
//defm vor : PRVIntBinBuiltinSet;
//defm vnot_v : PRVPseudoVNotBuiltin<"vxor", "csil">;
//
//// 12.6. Vector Single-Width Bit Shift Instructions
//defm vsll : PRVShiftBuiltinSet;
//defm vsrl : PRVUnsignedShiftBuiltinSet;
//defm vsra : PRVSignedShiftBuiltinSet;
//
//// 12.7. Vector Narrowing Integer Right Shift Instructions
//defm vnsrl : PRVUnsignedNShiftBuiltinSet;
//defm vnsra : PRVSignedNShiftBuiltinSet;
//defm vncvt_x_x_w : PRVPseudoVNCVTBuiltin<"vnsrl", "vncvt_x", "csi",
//                                         [["v", "vw"],
//                                          ["Uv", "UvUw"]]>;
//
//// 12.8. Vector Integer Comparison Instructions
//defm vmseq : PRVIntMaskOutBuiltinSet;
//defm vmsne : PRVIntMaskOutBuiltinSet;
//defm vmsltu : PRVUnsignedMaskOutBuiltinSet;
//defm vmslt : PRVSignedMaskOutBuiltinSet;
//defm vmsleu : PRVUnsignedMaskOutBuiltinSet;
//defm vmsle : PRVSignedMaskOutBuiltinSet;
//defm vmsgtu : PRVUnsignedMaskOutBuiltinSet;
//defm vmsgt : PRVSignedMaskOutBuiltinSet;
//defm vmsgeu : PRVUnsignedMaskOutBuiltinSet;
//defm vmsge : PRVSignedMaskOutBuiltinSet;
//
//// 12.9. Vector Integer Min/Max Instructions
//defm vminu : PRVUnsignedBinBuiltinSet;
//defm vmin : PRVSignedBinBuiltinSet;
//defm vmaxu : PRVUnsignedBinBuiltinSet;
//defm vmax : PRVSignedBinBuiltinSet;
//
//// 12.10. Vector Single-Width Integer Multiply Instructions
//defm vmul : PRVIntBinBuiltinSet;
//defm vmulh : PRVSignedBinBuiltinSet;
//defm vmulhu : PRVUnsignedBinBuiltinSet;
//defm vmulhsu : PRVOutOp1BuiltinSet<"vmulhsu", "csil",
//                                   [["vv", "v", "vvUv"],
//                                    ["vx", "v", "vvUe"]]>;
//
//// 12.11. Vector Integer Divide Instructions
//defm vdivu : PRVUnsignedBinBuiltinSet;
//defm vdiv : PRVSignedBinBuiltinSet;
//defm vremu : PRVUnsignedBinBuiltinSet;
//defm vrem : PRVSignedBinBuiltinSet;
//
//// 12.12. Vector Widening Integer Multiply Instructions
//let Log2LMUL = [-3, -2, -1, 0, 1, 2] in {
//defm vwmul : PRVOutOp0Op1BuiltinSet<"vwmul", "csi",
//                                    [["vv", "w", "wvv"],
//                                     ["vx", "w", "wve"]]>;
//defm vwmulu : PRVOutOp0Op1BuiltinSet<"vwmulu", "csi",
//                                     [["vv", "Uw", "UwUvUv"],
//                                      ["vx", "Uw", "UwUvUe"]]>;
//defm vwmulsu : PRVOutOp0Op1BuiltinSet<"vwmulsu", "csi",
//                                      [["vv", "w", "wvUv"],
//                                       ["vx", "w", "wvUe"]]>;
//}
//
//// 12.13. Vector Single-Width Integer Multiply-Add Instructions
//defm vmacc  : PRVIntTerBuiltinSet;
//defm vnmsac : PRVIntTerBuiltinSet;
//defm vmadd  : PRVIntTerBuiltinSet;
//defm vnmsub : PRVIntTerBuiltinSet;
//
//// 12.14. Vector Widening Integer Multiply-Add Instructions
//let HasMaskedOffOperand = false,
//    Log2LMUL = [-3, -2, -1, 0, 1, 2] in {
//defm vwmaccu : PRVOutOp1Op2BuiltinSet<"vwmaccu", "csi",
//                                      [["vv", "Uw", "UwUwUvUv"],
//                                       ["vx", "Uw", "UwUwUeUv"]]>;
//defm vwmacc : PRVOutOp1Op2BuiltinSet<"vwmacc", "csi",
//                                     [["vv", "w", "wwvv"],
//                                      ["vx", "w", "wwev"]]>;
//defm vwmaccsu : PRVOutOp1Op2BuiltinSet<"vwmaccsu", "csi",
//                                       [["vv", "w", "wwvUv"],
//                                        ["vx", "w", "wweUv"]]>;
//defm vwmaccus : PRVOutOp1Op2BuiltinSet<"vwmaccus", "csi",
//                                       [["vx", "w", "wwUev"]]>;
//}
//
//// 12.15. Vector Integer Merge Instructions
//// C/C++ Operand: (mask, op1, op2, vl), Intrinsic: (op1, op2, mask, vl)
//let HasMask = false,
//    ManualCodegen = [{
//      std::rotate(Ops.begin(), Ops.begin() + 1, Ops.begin() + 3);
//      IntrinsicTypes = {ResultType, Ops[1]->getType(), Ops[3]->getType()};
//    }] in {
//  defm vmerge : PRVOutOp1BuiltinSet<"vmerge", "csil",
//                                    [["vvm", "v", "vmvv"],
//                                     ["vxm", "v", "vmve"],
//                                     ["vvm", "Uv", "UvmUvUv"],
//                                     ["vxm", "Uv", "UvmUvUe"]]>;
//}
//
//// 12.16. Vector Integer Move Instructions
//let HasMask = false in {
//  let MangledName = "vmv_v" in {
//    defm vmv_v : PRVOutBuiltinSet<"vmv_v_v", "csil",
//                                   [["v", "Uv", "UvUv"]]>;
//    defm vmv_v : PRVOutBuiltinSet<"vmv_v_v", "csilxfd",
//                                   [["v", "v", "vv"]]>;
//  }
//  let HasNoMaskedOverloaded = false in
//    defm vmv_v : PRVOutBuiltinSet<"vmv_v_x", "csil",
//                                   [["x", "v", "ve"],
//                                    ["x", "Uv", "UvUe"]]>;
//}
//
//// 13. Vector Fixed-Point Arithmetic Instructions
//// 13.1. Vector Single-Width Saturating Add and Subtract
//defm vsaddu : PRVUnsignedBinBuiltinSet;
//defm vsadd : PRVSignedBinBuiltinSet;
//defm vssubu : PRVUnsignedBinBuiltinSet;
//defm vssub : PRVSignedBinBuiltinSet;
//
//// 13.2. Vector Single-Width Averaging Add and Subtract
//defm vaaddu : PRVUnsignedBinBuiltinSet;
//defm vaadd : PRVSignedBinBuiltinSet;
//defm vasubu : PRVUnsignedBinBuiltinSet;
//defm vasub : PRVSignedBinBuiltinSet;
//
//// 13.3. Vector Single-Width Fractional Multiply with Rounding and Saturation
//defm vsmul : PRVSignedBinBuiltinSet;
//
//// 13.4. Vector Single-Width Scaling Shift Instructions
//defm vssrl : PRVUnsignedShiftBuiltinSet;
//defm vssra : PRVSignedShiftBuiltinSet;
//
//// 13.5. Vector Narrowing Fixed-Point Clip Instructions
//defm vnclipu : PRVUnsignedNShiftBuiltinSet;
//defm vnclip : PRVSignedNShiftBuiltinSet;
//
//// 14. Vector Floating-Point Instructions
//// 14.2. Vector Single-Width Floating-Point Add/Subtract Instructions
//defm vfadd  : PRVFloatingBinBuiltinSet;
//defm vfsub  : PRVFloatingBinBuiltinSet;
//defm vfrsub : PRVFloatingBinVFBuiltinSet;
//
//// 14.3. Vector Widening Floating-Point Add/Subtract Instructions
//// Widening FP add/subtract, 2*SEW = SEW +/- SEW
//defm vfwadd : PRVFloatingWidenBinBuiltinSet;
//defm vfwsub : PRVFloatingWidenBinBuiltinSet;
//// Widening FP add/subtract, 2*SEW = 2*SEW +/- SEW
//defm vfwadd : PRVFloatingWidenOp0BinBuiltinSet;
//defm vfwsub : PRVFloatingWidenOp0BinBuiltinSet;
//
//// 14.4. Vector Single-Width Floating-Point Multiply/Divide Instructions
//defm vfmul  : PRVFloatingBinBuiltinSet;
//defm vfdiv  : PRVFloatingBinBuiltinSet;
//defm vfrdiv : PRVFloatingBinVFBuiltinSet;
//
//// 14.5. Vector Widening Floating-Point Multiply
//let Log2LMUL = [-2, -1, 0, 1, 2] in {
//  defm vfwmul : PRVOutOp0Op1BuiltinSet<"vfwmul", "xf",
//                                       [["vv", "w", "wvv"],
//                                        ["vf", "w", "wve"]]>;
//}
//
//// 14.6. Vector Single-Width Floating-Point Fused Multiply-Add Instructions
//defm vfmacc  : PRVFloatingTerBuiltinSet;
//defm vfnmacc : PRVFloatingTerBuiltinSet;
//defm vfmsac  : PRVFloatingTerBuiltinSet;
//defm vfnmsac : PRVFloatingTerBuiltinSet;
//defm vfmadd  : PRVFloatingTerBuiltinSet;
//defm vfnmadd : PRVFloatingTerBuiltinSet;
//defm vfmsub  : PRVFloatingTerBuiltinSet;
//defm vfnmsub : PRVFloatingTerBuiltinSet;
//
//// 14.7. Vector Widening Floating-Point Fused Multiply-Add Instructions
//defm vfwmacc  : PRVFloatingWidenTerBuiltinSet;
//defm vfwnmacc : PRVFloatingWidenTerBuiltinSet;
//defm vfwmsac  : PRVFloatingWidenTerBuiltinSet;
//defm vfwnmsac : PRVFloatingWidenTerBuiltinSet;
//
//// 14.8. Vector Floating-Point Square-Root Instruction
//def vfsqrt : PRVFloatingUnaryVVBuiltin;
//
//// 14.9. Vector Floating-Point Reciprocal Square-Root Estimate Instruction
//def vfrsqrt7 : PRVFloatingUnaryVVBuiltin;
//
//// 14.10. Vector Floating-Point Reciprocal Estimate Instruction
//def vfrec7 : PRVFloatingUnaryVVBuiltin;
//
//// 14.11. Vector Floating-Point MIN/MAX Instructions
//defm vfmin : PRVFloatingBinBuiltinSet;
//defm vfmax : PRVFloatingBinBuiltinSet;
//
//// 14.12. Vector Floating-Point Sign-Injection Instructions
//defm vfsgnj  : PRVFloatingBinBuiltinSet;
//defm vfsgnjn : PRVFloatingBinBuiltinSet;
//defm vfsgnjx : PRVFloatingBinBuiltinSet;
//defm vfneg_v : PRVPseudoVFUnaryBuiltin<"vfsgnjn", "xfd">;
//defm vfabs_v : PRVPseudoVFUnaryBuiltin<"vfsgnjx", "xfd">;
//
//// 14.13. Vector Floating-Point Compare Instructions
//defm vmfeq : PRVFloatingMaskOutBuiltinSet;
//defm vmfne : PRVFloatingMaskOutBuiltinSet;
//defm vmflt : PRVFloatingMaskOutBuiltinSet;
//defm vmfle : PRVFloatingMaskOutBuiltinSet;
//defm vmfgt : PRVFloatingMaskOutBuiltinSet;
//defm vmfge : PRVFloatingMaskOutBuiltinSet;
//
//// 14.14. Vector Floating-Point Classify Instruction
//let Name = "vfclass_v" in
//  def vfclass : PRVOp0Builtin<"Uv", "Uvv", "xfd">;
//
//// 14.15. Vector Floating-Point Merge Instructio
//// C/C++ Operand: (mask, op1, op2, vl), Builtin: (op1, op2, mask, vl)
//let HasMask = false,
//    ManualCodegen = [{
//      std::rotate(Ops.begin(), Ops.begin() + 1, Ops.begin() + 3);
//      IntrinsicTypes = {ResultType, Ops[1]->getType(), Ops[3]->getType()};
//    }] in {
//  defm vmerge : PRVOutOp1BuiltinSet<"vfmerge", "xfd",
//                                    [["vvm", "v", "vmvv"]]>;
//  defm vfmerge : PRVOutOp1BuiltinSet<"vfmerge", "xfd",
//                                    [["vfm", "v", "vmve"]]>;
//}
//
//// 14.16. Vector Floating-Point Move Instruction
//let HasMask = false, HasNoMaskedOverloaded = false in
//  defm vfmv_v : PRVOutBuiltinSet<"vfmv_v_f", "xfd",
//                                  [["f", "v", "ve"]]>;
//
//// 14.17. Single-Width Floating-Point/Integer Type-Convert Instructions
//def vfcvt_xu_f_v : PRVConvToUnsignedBuiltin<"vfcvt_xu">;
//def vfcvt_x_f_v : PRVConvToSignedBuiltin<"vfcvt_x">;
//def vfcvt_rtz_xu_f_v : PRVConvToUnsignedBuiltin<"vfcvt_rtz_xu">;
//def vfcvt_rtz_x_f_v : PRVConvToSignedBuiltin<"vfcvt_rtz_x">;
//def vfcvt_f_xu_v : PRVConvBuiltin<"Fv", "FvUv", "sil", "vfcvt_f">;
//def vfcvt_f_x_v : PRVConvBuiltin<"Fv", "Fvv", "sil", "vfcvt_f">;
//
//// 14.18. Widening Floating-Point/Integer Type-Convert Instructions
//let Log2LMUL = [-3, -2, -1, 0, 1, 2] in {
//  def vfwcvt_xu_f_v : PRVConvToWidenUnsignedBuiltin<"vfwcvt_xu">;
//  def vfwcvt_x_f_v : PRVConvToWidenSignedBuiltin<"vfwcvt_x">;
//  def vfwcvt_rtz_xu_f_v : PRVConvToWidenUnsignedBuiltin<"vfwcvt_rtz_xu">;
//  def vfwcvt_rtz_x_f_v : PRVConvToWidenSignedBuiltin<"vfwcvt_rtz_x">;
//  def vfwcvt_f_xu_v : PRVConvBuiltin<"Fw", "FwUv", "csi", "vfwcvt_f">;
//  def vfwcvt_f_x_v : PRVConvBuiltin<"Fw", "Fwv", "csi", "vfwcvt_f">;
//  def vfwcvt_f_f_v : PRVConvBuiltin<"w", "wv", "xf", "vfwcvt_f">;
//}
//
//// 14.19. Narrowing Floating-Point/Integer Type-Convert Instructions
//let Log2LMUL = [-3, -2, -1, 0, 1, 2] in {
//  def vfncvt_xu_f_w : PRVConvToNarrowingUnsignedBuiltin<"vfncvt_xu">;
//  def vfncvt_x_f_w : PRVConvToNarrowingSignedBuiltin<"vfncvt_x">;
//  def vfncvt_rtz_xu_f_w : PRVConvToNarrowingUnsignedBuiltin<"vfncvt_rtz_xu">;
//  def vfncvt_rtz_x_f_w : PRVConvToNarrowingSignedBuiltin<"vfncvt_rtz_x">;
//  def vfncvt_f_xu_w : PRVConvBuiltin<"Fv", "FvUw", "csi", "vfncvt_f">;
//  def vfncvt_f_x_w : PRVConvBuiltin<"Fv", "Fvw", "csi", "vfncvt_f">;
//  def vfncvt_f_f_w : PRVConvBuiltin<"v", "vw", "xf", "vfncvt_f">;
//  def vfncvt_rod_f_f_w : PRVConvBuiltin<"v", "vw", "xf", "vfncvt_rod_f">;
//}
//
//// 15. Vector Reduction Operations
//// 15.1. Vector Single-Width Integer Reduction Instructions
//defm vredsum : PRVIntReductionBuiltinSet;
//defm vredmaxu : PRVUnsignedReductionBuiltin;
//defm vredmax : PRVSignedReductionBuiltin;
//defm vredminu : PRVUnsignedReductionBuiltin;
//defm vredmin : PRVSignedReductionBuiltin;
//defm vredand : PRVIntReductionBuiltinSet;
//defm vredor : PRVIntReductionBuiltinSet;
//defm vredxor : PRVIntReductionBuiltinSet;
//
//// 15.2. Vector Widening Integer Reduction Instructions
//// Vector Widening Integer Reduction Operations
//let HasMaskedOffOperand = false in {
//  defm vwredsum : PRVOutOp1BuiltinSet<"vwredsum", "csi",
//                                      [["vs", "vSw", "SwSwvSw"]]>;
//  defm vwredsumu : PRVOutOp1BuiltinSet<"vwredsumu", "csi",
//                                       [["vs", "UvUSw", "USwUSwUvUSw"]]>;
//}
//
//// 15.3. Vector Single-Width Floating-Point Reduction Instructions
//defm vfredmax : PRVFloatingReductionBuiltin;
//defm vfredmin : PRVFloatingReductionBuiltin;
//defm vfredsum : PRVFloatingReductionBuiltin;
//defm vfredosum : PRVFloatingReductionBuiltin;
//
//// 15.4. Vector Widening Floating-Point Reduction Instructions
//defm vfwredsum : PRVFloatingWidenReductionBuiltin;
//defm vfwredosum : PRVFloatingWidenReductionBuiltin;
//
//// 16. Vector Mask Instructions
//// 16.1. Vector Mask-Register Logical Instructions
//def vmand    : PRVMaskBinBuiltin;
//def vmnand   : PRVMaskBinBuiltin;
//def vmandnot : PRVMaskBinBuiltin;
//def vmxor    : PRVMaskBinBuiltin;
//def vmor     : PRVMaskBinBuiltin;
//def vmnor    : PRVMaskBinBuiltin;
//def vmornot  : PRVMaskBinBuiltin;
//def vmxnor   : PRVMaskBinBuiltin;
//// pseudoinstructions
//def vmclr    : PRVMaskNullaryBuiltin;
//def vmset    : PRVMaskNullaryBuiltin;
//defm vmmv_m : PRVPseudoMaskBuiltin<"vmand", "c">;
//defm vmnot_m : PRVPseudoMaskBuiltin<"vmnand", "c">;
//
//// 16.2. Vector mask population count vpopc
//def vpopc : PRVMaskOp0Builtin<"um">;
//
//// 16.3. vfirst find-first-set mask bit
//def vfirst : PRVMaskOp0Builtin<"lm">;
//
//// 16.4. vmsbf.m set-before-first mask bit
//def vmsbf : PRVMaskUnaryBuiltin;
//
//// 16.5. vmsif.m set-including-first mask bit
//def vmsif : PRVMaskUnaryBuiltin;
//
//// 16.6. vmsof.m set-only-first mask bit
//def vmsof : PRVMaskUnaryBuiltin;
//
//let HasNoMaskedOverloaded = false in {
//  // 16.8. Vector Iota Instruction
//  defm viota : PRVOutBuiltinSet<"viota", "csil", [["m", "Uv", "Uvm"]]>;
//
//  // 16.9. Vector Element Index Instruction
//  defm vid : PRVOutBuiltinSet<"vid", "csil", [["v", "v", "v"],
//                                              ["v", "Uv", "Uv"]]>;
//}
//
//// 17. Vector Permutation Instructions
//// 17.1. Integer Scalar Move Instructions
//let HasMask = false in {
//  let HasVL = false, MangledName = "vmv_x" in
//    defm vmv_x : PRVOp0BuiltinSet<"vmv_x_s", "csil",
//                                   [["s", "ve", "ev"],
//                                    ["s", "UvUe", "UeUv"]]>;
//  let MangledName = "vmv_s" in
//    defm vmv_s : PRVOutBuiltinSet<"vmv_s_x", "csil",
//                                   [["x", "v", "vve"],
//                                    ["x", "Uv", "UvUvUe"]]>;
//}
//
//// 17.2. Floating-Point Scalar Move Instructions
//let HasMask = false in {
//  let HasVL = false, MangledName = "vfmv_f" in
//    defm vfmv_f : PRVOp0BuiltinSet<"vfmv_f_s", "xfd",
//                                     [["s", "ve", "ev"]]>;
//  let MangledName = "vfmv_s" in
//    defm vfmv_s : PRVOutBuiltinSet<"vfmv_s_f", "xfd",
//                                     [["f", "v", "vve"],
//                                      ["x", "Uv", "UvUvUe"]]>;
//}
//
//// 17.3. Vector Slide Instructions
//// 17.3.1. Vector Slideup Instructions
//defm vslideup   : PRVSlideBuiltinSet;
//// 17.3.2. Vector Slidedown Instructions
//defm vslidedown : PRVSlideBuiltinSet;
//
//// 17.3.3. Vector Slide1up Instructions
//defm vslide1up : PRVSlideOneBuiltinSet;
//defm vfslide1up : PRVFloatingBinVFBuiltinSet;
//
//// 17.3.4. Vector Slide1down Instruction
//defm vslide1down : PRVSlideOneBuiltinSet;
//defm vfslide1down : PRVFloatingBinVFBuiltinSet;
//
//// 17.4. Vector Register Gather Instructions
//// signed and floating type
//defm vrgather : PRVOutBuiltinSet<"vrgather_vv", "csilxfd",
//                                 [["vv", "v", "vvUv"]]>;
//defm vrgather : PRVOutBuiltinSet<"vrgather_vx", "csilxfd",
//                                 [["vx", "v", "vvz"]]>;
//defm vrgatherei16 : PRVOutBuiltinSet<"vrgatherei16_vv", "csilxfd",
//                                     [["vv", "v", "vv(Log2EEW:4)Uv"]]>;
//// unsigned type
//defm vrgather : PRVOutBuiltinSet<"vrgather_vv", "csil",
//                                 [["vv", "Uv", "UvUvUv"]]>;
//defm vrgather : PRVOutBuiltinSet<"vrgather_vx", "csil",
//                                 [["vx", "Uv", "UvUvz"]]>;
//defm vrgatherei16 : PRVOutBuiltinSet<"vrgatherei16_vv", "csil",
//                                     [["vv", "Uv", "UvUv(Log2EEW:4)Uv"]]>;
//
//// 17.5. Vector Compress Instruction
//let HasMask = false,
//    ManualCodegen = [{
//      std::rotate(Ops.begin(), Ops.begin() + 1, Ops.begin() + 3);
//      IntrinsicTypes = {ResultType, Ops[3]->getType()};
//    }] in {
//  // signed and floating type
//  defm vcompress : PRVOutBuiltinSet<"vcompress", "csilxfd",
//                                    [["vm", "v", "vmvv"]]>;
//  // unsigned type
//  defm vcompress : PRVOutBuiltinSet<"vcompress", "csil",
//                                    [["vm", "Uv", "UvmUvUv"]]>;
//}
//
//// Miscellaneous
//let HasMask = false, HasVL = false, IRName = "" in {
//  let Name = "vreinterpret_v",
//      ManualCodegen = [{
//        return Builder.CreateBitCast(Ops[0], ResultType);
//      }] in {
//    // Reinterpret between different type under the same SEW and LMUL
//    def vreinterpret_i_u : PRVBuiltin<"Uvv", "vUv", "csil", "v">;
//    def vreinterpret_i_f : PRVBuiltin<"Fvv", "vFv", "sil", "v">;
//    def vreinterpret_u_i : PRVBuiltin<"vUv", "Uvv", "csil", "Uv">;
//    def vreinterpret_u_f : PRVBuiltin<"FvUv", "UvFv", "sil", "Uv">;
//    def vreinterpret_f_i : PRVBuiltin<"vFv", "Fvv", "sil", "Fv">;
//    def vreinterpret_f_u : PRVBuiltin<"UvFv", "FvUv", "sil", "Fv">;
//
//    // Reinterpret between different SEW under the same LMUL
//    foreach dst_sew = ["(FixedSEW:8)", "(FixedSEW:16)", "(FixedSEW:32)",
//                       "(FixedSEW:64)"] in {
//      def vreinterpret_i_ # dst_sew : PRVBuiltin<"v" # dst_sew # "v",
//                                                 dst_sew # "vv", "csil", dst_sew # "v">;
//      def vreinterpret_u_ # dst_sew : PRVBuiltin<"Uv" # dst_sew # "Uv",
//                                                 dst_sew # "UvUv", "csil", dst_sew # "Uv">;
//    }
//  }
//
//  let Name = "vundefined", HasNoMaskedOverloaded = false,
//      ManualCodegen = [{
//        return llvm::UndefValue::get(ResultType);
//      }] in {
//    def vundefined : PRVBuiltin<"v", "v", "csilxfd">;
//    def vundefined_u : PRVBuiltin<"Uv", "Uv", "csil">;
//  }
//
//  // LMUL truncation
//  // C/C++ Operand: VecTy, IR Operand: VecTy, Index
//  let Name = "vlmul_trunc_v", MangledName = "vlmul_trunc",
//      ManualCodegen = [{ {
//        ID = Intrinsic::experimental_vector_extract;
//        IntrinsicTypes = {ResultType, Ops[0]->getType()};
//        Ops.push_back(ConstantInt::get(Int64Ty, 0));
//        return Builder.CreateCall(CGM.getIntrinsic(ID, IntrinsicTypes), Ops, "");
//      } }] in {
//    foreach dst_lmul = ["(SFixedLog2LMUL:-3)", "(SFixedLog2LMUL:-2)", "(SFixedLog2LMUL:-1)",
//                        "(SFixedLog2LMUL:0)", "(SFixedLog2LMUL:1)", "(SFixedLog2LMUL:2)"] in {
//      def vlmul_trunc # dst_lmul : PRVBuiltin<"v" # dst_lmul # "v",
//                                              dst_lmul # "vv", "csilxfd", dst_lmul # "v">;
//      def vlmul_trunc_u # dst_lmul : PRVBuiltin<"Uv" # dst_lmul # "Uv",
//                                                dst_lmul # "UvUv", "csil", dst_lmul # "Uv">;
//    }
//  }
//
//  // LMUL extension
//  // C/C++ Operand: SubVecTy, IR Operand: VecTy, SubVecTy, Index
//  let Name = "vlmul_ext_v", MangledName = "vlmul_ext",
//      ManualCodegen = [{
//        ID = Intrinsic::experimental_vector_insert;
//        IntrinsicTypes = {ResultType, Ops[0]->getType()};
//        Ops.push_back(llvm::UndefValue::get(ResultType));
//        std::swap(Ops[0], Ops[1]);
//        Ops.push_back(ConstantInt::get(Int64Ty, 0));
//        return Builder.CreateCall(CGM.getIntrinsic(ID, IntrinsicTypes), Ops, "");
//      }] in {
//    foreach dst_lmul = ["(LFixedLog2LMUL:-2)", "(LFixedLog2LMUL:-1)", "(LFixedLog2LMUL:-0)",
//                        "(LFixedLog2LMUL:1)", "(LFixedLog2LMUL:2)", "(LFixedLog2LMUL:3)"] in {
//      def vlmul_ext # dst_lmul : PRVBuiltin<"v" # dst_lmul # "v",
//                                            dst_lmul # "vv", "csilxfd", dst_lmul # "v">;
//      def vlmul_ext_u # dst_lmul : PRVBuiltin<"Uv" # dst_lmul # "Uv",
//                                              dst_lmul # "UvUv", "csil", dst_lmul # "Uv">;
//    }
//  }
//
//  let Name = "vget_v",
//      ManualCodegen = [{
//      {
//        ID = Intrinsic::experimental_vector_extract;
//        ScalableVectorType *VecTy = cast<ScalableVectorType>(ResultType);
//        Ops[1] = Builder.CreateMul(Ops[1],
//                                   ConstantInt::get(Ops[1]->getType(),
//                                                    VecTy->getMinNumElements()));
//        IntrinsicTypes = {ResultType, Ops[0]->getType()};
//        return Builder.CreateCall(CGM.getIntrinsic(ID, IntrinsicTypes), Ops, "");
//      }
//      }] in {
//    foreach dst_lmul = ["(SFixedLog2LMUL:0)", "(SFixedLog2LMUL:1)", "(SFixedLog2LMUL:2)"] in {
//      def : PRVBuiltin<"v" # dst_lmul # "v", dst_lmul # "vvKz", "csilfd", dst_lmul # "v">;
//      def : PRVBuiltin<"Uv" # dst_lmul # "Uv", dst_lmul # "UvUvKz", "csil", dst_lmul # "Uv">;
//    }
//  }
//
//  let Name = "vset_v", Log2LMUL = [0, 1, 2],
//      ManualCodegen = [{
//      {
//        ID = Intrinsic::experimental_vector_insert;
//        IntrinsicTypes = {ResultType, Ops[2]->getType()};
//        ScalableVectorType *VecTy = cast<ScalableVectorType>(Ops[2]->getType());
//        Ops[1] = Builder.CreateMul(Ops[1],
//                                   ConstantInt::get(Ops[1]->getType(),
//                                                    VecTy->getMinNumElements()));
//        std::swap(Ops[1], Ops[2]);
//        return Builder.CreateCall(CGM.getIntrinsic(ID, IntrinsicTypes), Ops, "");
//      }
//      }] in {
//    foreach dst_lmul = ["(LFixedLog2LMUL:1)", "(LFixedLog2LMUL:2)", "(LFixedLog2LMUL:3)"] in {
//      def : PRVBuiltin<"v" # dst_lmul # "v", dst_lmul # "v" # dst_lmul # "vKzv", "csilfd">;
//      def : PRVBuiltin<"Uv" # dst_lmul # "Uv", dst_lmul # "Uv" # dst_lmul #"UvKzUv", "csil">;
//    }
//  }
//}
