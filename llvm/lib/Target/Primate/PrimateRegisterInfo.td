//===-- PrimateRegisterInfo.td - Primate Register defs -----*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
//  Declarations that describe the Primate register files
//===----------------------------------------------------------------------===//

let Namespace = "Primate" in {
class PrimateReg<bits<5> Enc, string n, list<string> alt = []> : Register<n> {
  let HWEncoding{4-0} = Enc;
  let AltNames = alt;
}

class PrimateReg16<bits<5> Enc, string n, list<string> alt = []> : Register<n> {
  let HWEncoding{4-0} = Enc;
  let AltNames = alt;
}

def sub_16 : SubRegIndex<16>;
class PrimateReg32<PrimateReg16 subreg> : Register<""> {
  let HWEncoding{4-0} = subreg.HWEncoding{4-0};
  let SubRegs = [subreg];
  let SubRegIndices = [sub_16];
  let AsmName = subreg.AsmName;
  let AltNames = subreg.AltNames;
}

// Because PrimateReg64 register have AsmName and AltNames that alias with their
// 16/32-bit sub-register, PrimateAsmParser will need to coerce a register number
// from a PrimateReg16/PrimateReg32 to the equivalent PrimateReg64 when appropriate.
def sub_32 : SubRegIndex<32>;
class PrimateReg64<PrimateReg32 subreg> : Register<""> {
  let HWEncoding{4-0} = subreg.HWEncoding{4-0};
  let SubRegs = [subreg];
  let SubRegIndices = [sub_32];
  let AsmName = subreg.AsmName;
  let AltNames = subreg.AltNames;
}

class PrimateRegWithSubRegs<bits<5> Enc, string n, list<Register> subregs,
                          list<string> alt = []>
      : RegisterWithSubRegs<n, subregs> {
  let HWEncoding{4-0} = Enc;
  let AltNames = alt;
}

def ABIRegAltName : RegAltNameIndex;

def sub_vrm4_0 : SubRegIndex<256>;
def sub_vrm4_1 : SubRegIndex<256, 256>;
def sub_vrm2_0 : SubRegIndex<128>;
def sub_vrm2_1 : SubRegIndex<128, 128>;
def sub_vrm2_2 : ComposedSubRegIndex<sub_vrm4_1, sub_vrm2_0>;
def sub_vrm2_3 : ComposedSubRegIndex<sub_vrm4_1, sub_vrm2_1>;
def sub_vrm1_0 : SubRegIndex<64>;
def sub_vrm1_1 : SubRegIndex<64, 64>;
def sub_vrm1_2 : ComposedSubRegIndex<sub_vrm2_1, sub_vrm1_0>;
def sub_vrm1_3 : ComposedSubRegIndex<sub_vrm2_1, sub_vrm1_1>;
def sub_vrm1_4 : ComposedSubRegIndex<sub_vrm2_2, sub_vrm1_0>;
def sub_vrm1_5 : ComposedSubRegIndex<sub_vrm2_2, sub_vrm1_1>;
def sub_vrm1_6 : ComposedSubRegIndex<sub_vrm2_3, sub_vrm1_0>;
def sub_vrm1_7 : ComposedSubRegIndex<sub_vrm2_3, sub_vrm1_1>;

def gpr_idx : SubRegIndex<32, 0>;
def Pri_hanger : SubRegIndex<128, 0>;

} // Namespace = "Primate"

foreach Index = 0-31 in {
  // Pseudo regs
  let RegAltNameIndices = [ABIRegAltName] in {
    def X#Index  : PrimateReg<Index, "x"#Index, ["x"#Index]>, DwarfRegNum<[Index]>;
    def H#Index  : PrimateReg<Index, "h"#Index, ["h"#Index]>, DwarfRegNum<[Index]>{
      let SubRegIndices = [gpr_idx];
      let SubRegs = [!cast<Register>("X"#Index)];
    }
    def P#Index : PrimateReg<Index, "p"#Index, ["p"#Index]>, DwarfRegNum<[Index]> {
      let SubRegIndices = [Pri_hanger];
      let SubRegs = [!cast<Register>("H"#Index)];
      //let CoveredBySubRegs = true;
    }
  }
}

// Value type of the aggregate register file
def PrimateAGGVT : ValueTypeByHwMode<[PR32, PR64],
                               [Primate_aggregate,  Primate_aggregate]>;
// register info of the aggregate register file
def PrimateAGGRI : RegInfoByHwMode<
  [PR32, PR64],
  [RegInfo<32,32,32>, RegInfo<32,32,32>]
>;

def HoldingRegVT : ValueTypeByHwMode<[PR32, PR64],
                               [i128,  i128]>;
def HoldingRegRI : RegInfoByHwMode<
      [PR32,              PR64],
      [RegInfo<128,128,128>, RegInfo<128,128,128>]>;

def XLenVT : ValueTypeByHwMode<[PR32, PR64],
                               [i32,  i64]>;
def XLenRI : RegInfoByHwMode<
      [PR32,              PR64],
      [RegInfo<32,32,32>, RegInfo<64,64,64>]>;

// The order of registers represents the preferred allocation sequence.
// Registers are listed in the order caller-save, callee-save, specials.
def GPR : RegisterClass<"Primate", [XLenVT], 32, (add
    (sequence "X%u", 0, 31)
  )> {
  let RegInfos = XLenRI;
}

// The order of registers represents the preferred allocation sequence.
// Registers are listed in the order caller-save, callee-save, specials.
def GPR128 : RegisterClass<"Primate", [HoldingRegVT], 32, (add
    (sequence "H%u", 0, 31)
  )> {
  let RegInfos = HoldingRegRI;
}

def WIDEREG : RegisterClass<"Primate", [PrimateAGGVT], 32, (add 
    (sequence "P%u", 0, 31)
  )> {
    let RegInfos = PrimateAGGRI;
  }

def GPRX0 : RegisterClass<"Primate", [XLenVT], 32, (add X0)> {
  let RegInfos = XLenRI;
}

// The order of registers represents the preferred allocation sequence.
// Registers are listed in the order caller-save, callee-save, specials.
def GPRNoX0 : RegisterClass<"Primate", [XLenVT], 32, (add
    (sequence "X%u", 10, 17),
    (sequence "X%u", 5, 7),
    (sequence "X%u", 28, 31),
    (sequence "X%u", 8, 9),
    (sequence "X%u", 18, 27),
    (sequence "X%u", 1, 4)
  )> {
  let RegInfos = XLenRI;
}

def GPRNoX0X2 : RegisterClass<"Primate", [XLenVT], 32, (add
    (sequence "X%u", 10, 17),
    (sequence "X%u", 5, 7),
    (sequence "X%u", 28, 31),
    (sequence "X%u", 8, 9),
    (sequence "X%u", 18, 27),
    X1, X3, X4
  )> {
  let RegInfos = XLenRI;
}

// Don't use X1 or X5 for JALR since that is a hint to pop the return address
// stack on some microarchitectures. Also remove the reserved registers X0, X2,
// X3, and X4 as it reduces the number of register classes that get synthesized
// by tablegen.
def GPRJALR : RegisterClass<"Primate", [XLenVT], 32, (add
    (sequence "X%u", 10, 17),
    (sequence "X%u", 6, 7),
    (sequence "X%u", 28, 31),
    (sequence "X%u", 8, 9),
    (sequence "X%u", 18, 27)
  )> {
  let RegInfos = XLenRI;
}

def GPRC : RegisterClass<"Primate", [XLenVT], 32, (add
    (sequence "X%u", 10, 15),
    (sequence "X%u", 8, 9)
  )> {
  let RegInfos = XLenRI;
}

// For indirect tail calls, we can't use callee-saved registers, as they are
// restored to the saved value before the tail call, which would clobber a call
// address. We shouldn't use x5 since that is a hint for to pop the return
// address stack on some microarchitectures.
def GPRTC : RegisterClass<"Primate", [XLenVT], 32, (add
    (sequence "X%u", 6, 7),
    (sequence "X%u", 10, 17),
    (sequence "X%u", 28, 31)
  )> {
  let RegInfos = XLenRI;
}

def SP : RegisterClass<"Primate", [XLenVT], 32, (add X2)> {
  let RegInfos = XLenRI;
}

// Floating point registers
let RegAltNameIndices = [ABIRegAltName] in {
  def F0_H  : PrimateReg16<0, "f0", ["ft0"]>, DwarfRegNum<[32]>;
  def F1_H  : PrimateReg16<1, "f1", ["ft1"]>, DwarfRegNum<[33]>;
  def F2_H  : PrimateReg16<2, "f2", ["ft2"]>, DwarfRegNum<[34]>;
  def F3_H  : PrimateReg16<3, "f3", ["ft3"]>, DwarfRegNum<[35]>;
  def F4_H  : PrimateReg16<4, "f4", ["ft4"]>, DwarfRegNum<[36]>;
  def F5_H  : PrimateReg16<5, "f5", ["ft5"]>, DwarfRegNum<[37]>;
  def F6_H  : PrimateReg16<6, "f6", ["ft6"]>, DwarfRegNum<[38]>;
  def F7_H  : PrimateReg16<7, "f7", ["ft7"]>, DwarfRegNum<[39]>;
  def F8_H  : PrimateReg16<8, "f8", ["fs0"]>, DwarfRegNum<[40]>;
  def F9_H  : PrimateReg16<9, "f9", ["fs1"]>, DwarfRegNum<[41]>;
  def F10_H : PrimateReg16<10,"f10", ["fa0"]>, DwarfRegNum<[42]>;
  def F11_H : PrimateReg16<11,"f11", ["fa1"]>, DwarfRegNum<[43]>;
  def F12_H : PrimateReg16<12,"f12", ["fa2"]>, DwarfRegNum<[44]>;
  def F13_H : PrimateReg16<13,"f13", ["fa3"]>, DwarfRegNum<[45]>;
  def F14_H : PrimateReg16<14,"f14", ["fa4"]>, DwarfRegNum<[46]>;
  def F15_H : PrimateReg16<15,"f15", ["fa5"]>, DwarfRegNum<[47]>;
  def F16_H : PrimateReg16<16,"f16", ["fa6"]>, DwarfRegNum<[48]>;
  def F17_H : PrimateReg16<17,"f17", ["fa7"]>, DwarfRegNum<[49]>;
  def F18_H : PrimateReg16<18,"f18", ["fs2"]>, DwarfRegNum<[50]>;
  def F19_H : PrimateReg16<19,"f19", ["fs3"]>, DwarfRegNum<[51]>;
  def F20_H : PrimateReg16<20,"f20", ["fs4"]>, DwarfRegNum<[52]>;
  def F21_H : PrimateReg16<21,"f21", ["fs5"]>, DwarfRegNum<[53]>;
  def F22_H : PrimateReg16<22,"f22", ["fs6"]>, DwarfRegNum<[54]>;
  def F23_H : PrimateReg16<23,"f23", ["fs7"]>, DwarfRegNum<[55]>;
  def F24_H : PrimateReg16<24,"f24", ["fs8"]>, DwarfRegNum<[56]>;
  def F25_H : PrimateReg16<25,"f25", ["fs9"]>, DwarfRegNum<[57]>;
  def F26_H : PrimateReg16<26,"f26", ["fs10"]>, DwarfRegNum<[58]>;
  def F27_H : PrimateReg16<27,"f27", ["fs11"]>, DwarfRegNum<[59]>;
  def F28_H : PrimateReg16<28,"f28", ["ft8"]>, DwarfRegNum<[60]>;
  def F29_H : PrimateReg16<29,"f29", ["ft9"]>, DwarfRegNum<[61]>;
  def F30_H : PrimateReg16<30,"f30", ["ft10"]>, DwarfRegNum<[62]>;
  def F31_H : PrimateReg16<31,"f31", ["ft11"]>, DwarfRegNum<[63]>;

  foreach Index = 0-31 in {
    def F#Index#_F : PrimateReg32<!cast<PrimateReg16>("F"#Index#"_H")>,
      DwarfRegNum<[!add(Index, 32)]>;
  }

  foreach Index = 0-31 in {
    def F#Index#_D : PrimateReg64<!cast<PrimateReg32>("F"#Index#"_F")>,
      DwarfRegNum<[!add(Index, 32)]>;
  }
}

// The order of registers represents the preferred allocation sequence,
// meaning caller-save regs are listed before callee-save.
def FPR16 : RegisterClass<"Primate", [f16], 16, (add
    (sequence "F%u_H", 0, 7),
    (sequence "F%u_H", 10, 17),
    (sequence "F%u_H", 28, 31),
    (sequence "F%u_H", 8, 9),
    (sequence "F%u_H", 18, 27)
)>;

def FPR32 : RegisterClass<"Primate", [f32], 32, (add
    (sequence "F%u_F", 0, 7),
    (sequence "F%u_F", 10, 17),
    (sequence "F%u_F", 28, 31),
    (sequence "F%u_F", 8, 9),
    (sequence "F%u_F", 18, 27)
)>;

def FPR32C : RegisterClass<"Primate", [f32], 32, (add
  (sequence "F%u_F", 10, 15),
  (sequence "F%u_F", 8, 9)
)>;

// The order of registers represents the preferred allocation sequence,
// meaning caller-save regs are listed before callee-save.
def FPR64 : RegisterClass<"Primate", [f64], 64, (add
    (sequence "F%u_D", 0, 7),
    (sequence "F%u_D", 10, 17),
    (sequence "F%u_D", 28, 31),
    (sequence "F%u_D", 8, 9),
    (sequence "F%u_D", 18, 27)
)>;

def FPR64C : RegisterClass<"Primate", [f64], 64, (add
  (sequence "F%u_D", 10, 15),
  (sequence "F%u_D", 8, 9)
)>;

// Vector type mapping to LLVM types.
//
// The V vector extension requires that VLEN >= 128 and <= 65536.
// Additionally, the only supported ELEN values are 32 and 64,
// thus `vscale` can be defined as VLEN/64,
// allowing the same types with either ELEN value.
//
//         MF8    MF4     MF2     M1      M2      M4       M8
// i64*    N/A    N/A     N/A     nxv1i64 nxv2i64 nxv4i64  nxv8i64
// i32     N/A    N/A     nxv1i32 nxv2i32 nxv4i32 nxv8i32  nxv16i32
// i16     N/A    nxv1i16 nxv2i16 nxv4i16 nxv8i16 nxv16i16 nxv32i16
// i8      nxv1i8 nxv2i8  nxv4i8  nxv8i8  nxv16i8 nxv32i8  nxv64i8
// double* N/A    N/A     N/A     nxv1f64 nxv2f64 nxv4f64  nxv8f64
// float   N/A    N/A     nxv1f32 nxv2f32 nxv4f32 nxv8f32  nxv16f32
// half    N/A    nxv1f16 nxv2f16 nxv4f16 nxv8f16 nxv16f16 nxv32f16
// * ELEN=64

defvar vint8mf8_t = nxv1i8;
defvar vint8mf4_t = nxv2i8;
defvar vint8mf2_t = nxv4i8;
defvar vint8m1_t = nxv8i8;
defvar vint8m2_t = nxv16i8;
defvar vint8m4_t = nxv32i8;
defvar vint8m8_t = nxv64i8;

defvar vint16mf4_t = nxv1i16;
defvar vint16mf2_t = nxv2i16;
defvar vint16m1_t  = nxv4i16;
defvar vint16m2_t  = nxv8i16;
defvar vint16m4_t  = nxv16i16;
defvar vint16m8_t  = nxv32i16;

defvar vint32mf2_t = nxv1i32;
defvar vint32m1_t  = nxv2i32;
defvar vint32m2_t  = nxv4i32;
defvar vint32m4_t  = nxv8i32;
defvar vint32m8_t  = nxv16i32;

defvar vint64m1_t = nxv1i64;
defvar vint64m2_t = nxv2i64;
defvar vint64m4_t = nxv4i64;
defvar vint64m8_t = nxv8i64;

defvar vfloat16mf4_t = nxv1f16;
defvar vfloat16mf2_t = nxv2f16;
defvar vfloat16m1_t  = nxv4f16;
defvar vfloat16m2_t  = nxv8f16;
defvar vfloat16m4_t  = nxv16f16;
defvar vfloat16m8_t  = nxv32f16;

defvar vfloat32mf2_t = nxv1f32;
defvar vfloat32m1_t  = nxv2f32;
defvar vfloat32m2_t  = nxv4f32;
defvar vfloat32m4_t  = nxv8f32;
defvar vfloat32m8_t  = nxv16f32;

defvar vfloat64m1_t = nxv1f64;
defvar vfloat64m2_t = nxv2f64;
defvar vfloat64m4_t = nxv4f64;
defvar vfloat64m8_t = nxv8f64;

defvar vbool1_t  = nxv64i1;
defvar vbool2_t  = nxv32i1;
defvar vbool4_t  = nxv16i1;
defvar vbool8_t  = nxv8i1;
defvar vbool16_t = nxv4i1;
defvar vbool32_t = nxv2i1;
defvar vbool64_t = nxv1i1;

// There is no need to define register classes for fractional LMUL.
def LMULList {
  list<int> m = [1, 2, 4, 8];
}

//===----------------------------------------------------------------------===//
// Utility classes for segment load/store.
//===----------------------------------------------------------------------===//
// The set of legal NF for LMUL = lmul.
// LMUL == 1, NF = 2, 3, 4, 5, 6, 7, 8
// LMUL == 2, NF = 2, 3, 4
// LMUL == 4, NF = 2
class NFList<int lmul> {
  list<int> L = !cond(!eq(lmul, 1): [2, 3, 4, 5, 6, 7, 8],
                      !eq(lmul, 2): [2, 3, 4],
                      !eq(lmul, 4): [2],
                      !eq(lmul, 8): []);
}

// Generate [start, end) SubRegIndex list.
class SubRegSet<list<SubRegIndex> LIn, int start, int nf, int lmul> {
  list<SubRegIndex> L = !foldl([]<SubRegIndex>,
                               [0, 1, 2, 3, 4, 5, 6, 7],
                               AccList, i,
                               !listconcat(AccList,
                                 !if(!lt(i, nf),
                                   [!cast<SubRegIndex>("sub_vrm" # lmul # "_" # i)],
                                   [])));
}

class IndexSet<int index, int nf, int lmul> {
  list<int> R =
    !foldl([]<int>,
              [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
               13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
               23, 24, 25, 26, 27, 28, 29, 30, 31],
              L, i,
              !listconcat(L,
                          !if(!and(
                                !le(!mul(index, lmul), !mul(i, lmul)),
                                !le(!mul(i, lmul),
                                    !sub(!add(32, !mul(index, lmul)), !mul(nf, lmul)))
                              ), [!mul(i, lmul)], [])));
}

class VRegList<list<dag> LIn, int start, int nf, int lmul, bit NoV0> {
  list<dag> L =
    !if(!ge(start, nf),
        LIn,
        !listconcat(
          [!dag(add,
                !foreach(i,
                  !if(NoV0,
                    !tail(IndexSet<start, nf, lmul>.R),
                    [!head(IndexSet<start, nf, lmul>.R)]),
                  !cast<Register>("V" # i # !cond(!eq(lmul, 2): "M2",
                                                  !eq(lmul, 4): "M4",
                                                  true: ""))),
                !listsplat("",
                  !if(NoV0,
                    !size(!tail(IndexSet<start, nf, lmul>.R)),
                    !size([!head(IndexSet<start, nf, lmul>.R)]))))],
          VRegList<LIn, !add(start, 1), nf, lmul, NoV0>.L));
}

// Vector registers
let RegAltNameIndices = [ABIRegAltName] in {
  foreach Index = 0-31 in {
    def V#Index : PrimateReg<Index, "v"#Index, ["v"#Index]>, DwarfRegNum<[!add(Index, 96)]>;
  }

  foreach Index = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
                   24, 26, 28, 30] in {
    def V#Index#M2 : PrimateRegWithSubRegs<Index, "v"#Index,
                       [!cast<Register>("V"#Index),
                        !cast<Register>("V"#!add(Index, 1))],
                       ["v"#Index]>,
                     DwarfRegAlias<!cast<Register>("V"#Index)> {
      let SubRegIndices = [sub_vrm1_0, sub_vrm1_1];
    }
  }

  foreach Index = [0, 4, 8, 12, 16, 20, 24, 28] in {
    def V#Index#M4 : PrimateRegWithSubRegs<Index, "v"#Index,
                       [!cast<Register>("V"#Index#"M2"),
                        !cast<Register>("V"#!add(Index, 2)#"M2")],
                       ["v"#Index]>,
                     DwarfRegAlias<!cast<Register>("V"#Index)> {
      let SubRegIndices = [sub_vrm2_0, sub_vrm2_1];
    }
  }

  foreach Index = [0, 8, 16, 24] in {
    def V#Index#M8 : PrimateRegWithSubRegs<Index, "v"#Index,
                       [!cast<Register>("V"#Index#"M4"),
                        !cast<Register>("V"#!add(Index, 4)#"M4")],
                       ["v"#Index]>,
                     DwarfRegAlias<!cast<Register>("V"#Index)> {
      let SubRegIndices = [sub_vrm4_0, sub_vrm4_1];
    }
  }

  def VTYPE  : PrimateReg<0, "vtype", ["vtype"]>;
  def VL     : PrimateReg<0, "vl", ["vl"]>;
  def VXSAT  : PrimateReg<0, "vxsat", ["vxsat"]>;
  def VXRM   : PrimateReg<0, "vxrm", ["vxrm"]>;
}

foreach m = [1, 2, 4] in {
  foreach n = NFList<m>.L in {
    def "VN" # n # "M" # m # "NoV0": RegisterTuples<
                                       SubRegSet<[], 0, n, m>.L,
                                       VRegList<[], 0, n, m, 1>.L>;
    def "VN" # n # "M" # m # "V0" : RegisterTuples<
                                       SubRegSet<[], 0, n, m>.L,
                                       VRegList<[], 0, n, m, 0>.L>;
  }
}

class VReg<list<ValueType> regTypes, dag regList, int Vlmul>
  : RegisterClass<"Primate",
                  regTypes,
                  64, // The maximum supported ELEN is 64.
                  regList> {
  int VLMul = Vlmul;
  int Size = !mul(Vlmul, 64);
}

def VR : VReg<[vint8m1_t, vint16m1_t, vint32m1_t, vint64m1_t,
               vfloat16m1_t, vfloat32m1_t, vfloat64m1_t,
               vint8mf2_t, vint8mf4_t, vint8mf8_t,
               vint16mf2_t, vint16mf4_t, vint32mf2_t,
               vfloat16mf4_t, vfloat16mf2_t, vfloat32mf2_t,
               vbool64_t, vbool32_t, vbool16_t, vbool8_t, vbool4_t,
               vbool2_t, vbool1_t],
           (add (sequence "V%u", 25, 31),
                (sequence "V%u", 8, 24),
                (sequence "V%u", 0, 7)), 1>;

def VRNoV0 : VReg<[vint8m1_t, vint16m1_t, vint32m1_t, vint64m1_t,
                   vfloat16m1_t, vfloat32m1_t, vfloat64m1_t,
                   vint8mf2_t, vint8mf4_t, vint8mf8_t,
                   vint16mf2_t, vint16mf4_t, vint32mf2_t,
                   vfloat16mf4_t, vfloat16mf2_t, vfloat32mf2_t,
                   vbool64_t, vbool32_t, vbool16_t, vbool8_t, vbool4_t,
                   vbool2_t, vbool1_t],
               (add (sequence "V%u", 25, 31),
                    (sequence "V%u", 8, 24),
                    (sequence "V%u", 1, 7)), 1>;

def VRM2 : VReg<[vint8m2_t, vint16m2_t, vint32m2_t, vint64m2_t,
                 vfloat16m2_t, vfloat32m2_t, vfloat64m2_t],
             (add V26M2, V28M2, V30M2, V8M2, V10M2, V12M2, V14M2, V16M2,
                  V18M2, V20M2, V22M2, V24M2, V0M2, V2M2, V4M2, V6M2), 2>;

def VRM2NoV0 : VReg<[vint8m2_t, vint16m2_t, vint32m2_t, vint64m2_t,
                     vfloat16m2_t, vfloat32m2_t, vfloat64m2_t],
                 (add V26M2, V28M2, V30M2, V8M2, V10M2, V12M2, V14M2, V16M2,
                      V18M2, V20M2, V22M2, V24M2, V2M2, V4M2, V6M2), 2>;

def VRM4 : VReg<[vint8m4_t, vint16m4_t, vint32m4_t, vint64m4_t,
                 vfloat16m4_t, vfloat32m4_t, vfloat64m4_t],
             (add V28M4, V8M4, V12M4, V16M4, V20M4, V24M4, V0M4, V4M4), 4>;

def VRM4NoV0 : VReg<[vint8m4_t, vint16m4_t, vint32m4_t, vint64m4_t,
                     vfloat16m4_t, vfloat32m4_t, vfloat64m4_t],
                 (add V28M4, V8M4, V12M4, V16M4, V20M4, V24M4, V4M4), 4>;

def VRM8 : VReg<[vint8m8_t, vint16m8_t, vint32m8_t, vint64m8_t,
                 vfloat16m8_t, vfloat32m8_t, vfloat64m8_t],
             (add V8M8, V16M8, V24M8, V0M8), 8>;

def VRM8NoV0 : VReg<[vint8m8_t, vint16m8_t, vint32m8_t, vint64m8_t,
                     vfloat16m8_t, vfloat32m8_t, vfloat64m8_t],
                 (add V8M8, V16M8, V24M8), 8>;

defvar VMaskVTs = [vbool64_t, vbool32_t, vbool16_t, vbool8_t,
                   vbool4_t, vbool2_t, vbool1_t];

def VMV0 : RegisterClass<"Primate", VMaskVTs, 64, (add V0)> {
  let Size = 64;
}

// The register class is added for inline assembly for vector mask types.
def VM : VReg<[vbool1_t, vbool2_t, vbool4_t, vbool8_t, vbool16_t,
               vbool32_t, vbool64_t],
           (add (sequence "V%u", 25, 31),
                (sequence "V%u", 8, 24),
                (sequence "V%u", 0, 7)), 1>;

foreach m = LMULList.m in {
  foreach nf = NFList<m>.L in {
    def "VRN" # nf # "M" # m: VReg<[untyped],
                               (add !cast<RegisterTuples>("VN" # nf # "M" # m # "V0"), !cast<RegisterTuples>("VN" # nf # "M" # m # "NoV0")),
                                    !mul(nf, m)>;
    def "VRN" # nf # "M" # m # "NoV0": VReg<[untyped],
                               (add !cast<RegisterTuples>("VN" # nf # "M" # m # "NoV0")),
                                    !mul(nf, m)>;
  }
}

// Special registers
def FFLAGS : PrimateReg<0, "fflags">;
def FRM    : PrimateReg<0, "frm">;
def FCSR   : PrimateReg<0, "fcsr">;
